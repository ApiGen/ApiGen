<?php
/**
 * PHP Token Reflection
 *
 * Pre-release testing version
 * Comming soon at https://github.com/Andrewsville/PHP-Token-Reflection
 *
 * LICENSE
 *
 * This source file is subject to the new BSD license that is bundled
 * with this library in the file license.txt.
 *
 * @author Ondřej Nešpor <andrew@andrewsville.cz>
 * @author Jaroslav Hanslík <kukulich@kukulich.cz>
 */
 namespace TokenReflection\Broker;use TokenReflection\ReflectionFile,TokenReflection\Broker as BrokerParent;interface Backend{const TOKENIZED_CLASSES=1;const INTERNAL_CLASSES=2;const NONEXISTENT_CLASSES=4;public function getNamespace($namespaceName);public function getClass($className);public function getFunction($functionName);public function getConstant($constantName);public function isFileProcessed($fileName);public function getFileTokens($fileName);public function addFile(ReflectionFile$file);public function setBroker(BrokerParent$broker);public function getBroker();public function setStoringTokenStreams($store);public function getStoringTokenStreams();public function getClasses($type=Backend::TOKENIZED_CLASSES);}
 namespace TokenReflection;use TokenReflection\Broker\Backend;use ArrayIterator,RecursiveDirectoryIterator,RecursiveIteratorIterator;use RuntimeException;class Broker{const CACHE_CLASS='class';const CACHE_FUNCTION='function';const CACHE_CONSTANT='constant';const CACHE_NAMESPACE='namespace';private$backend;private$cache;public function __construct(Backend$backend,$storingTokenStream=true){$this->cache=array(self::CACHE_CLASS => array(),self::CACHE_CONSTANT => array(),self::CACHE_FUNCTION => array(),self::CACHE_NAMESPACE => array());$this->backend=$backend ->setBroker($this)->setStoringTokenStreams($storingTokenStream);}public function processFile($filename){$realName=realpath($filename);if(false ===$realName){throw new Exception(sprintf('File %s does not exist',$filename),Exception::FILE_DOES_NOT_EXIST);}if($this->backend->isFileProcessed($realName)){$tokens=$this->backend->getFileTokens($realName);}else{$contents=@file_get_contents($filename);if(false ===$contents){throw new Exception('File is not readable',Exception::FILE_NOT_READABLE);}static$checkLines=array(T_COMMENT,T_WHITESPACE,T_DOC_COMMENT,T_INLINE_HTML,T_ENCAPSED_AND_WHITESPACE,T_CONSTANT_ENCAPSED_STRING);$actualLine=0;$tmp=null;$tokens=@token_get_all($contents);foreach($tokens as$index =>$token){if(!is_array($token)){if(0 ===$index){throw new RuntimeException('The first token has to be a complete one.');}$tokens[$index]=array($token,$token,$actualLine);}else{$actualLine=$token[2];if(in_array($token[0],$checkLines)){$actualLine += preg_match_all('~[\\r\\n]~',$token[1],$tmp);}}}}$reflectionFile=new ReflectionFile($realName,$tokens,$this);if(!$this->backend->isFileProcessed($realName)){$this->backend->addFile($reflectionFile);foreach($this->cache as$type =>$cached){if(!empty($cached)){$this->cache[$type]=array_filter($cached,function(IReflection$reflection){return$reflection->isTokenized();});}}}return$reflectionFile;}public function processDirectory($path){$realPath=realpath($path);if(false ===$realPath){throw new Exception(sprintf('Directory %s does not exist',$path),Exception::FILE_DOES_NOT_EXIST);}$result=array();foreach(new RecursiveIteratorIterator(new RecursiveDirectoryIterator($realPath))as$entry){if($entry->isFile()){$result[$entry->getPathName()]=$this->processFile($entry->getPathName());}}return$result;}public function getNamespace($namespaceName){$namespaceName=ltrim($namespaceName,'\\');if(isset($this->cache[self::CACHE_NAMESPACE][$namespaceName])){return$this->cache[self::CACHE_NAMESPACE][$namespaceName];}$namespace=$this->backend->getNamespace($namespaceName);if(null !==$namespace){$this->cache[self::CACHE_NAMESPACE][$namespaceName]=$namespaceName;}return$namespace;}public function getClass($className){$className=ltrim($className,'\\');if(isset($this->cache[self::CACHE_CLASS][$className])){return$this->cache[self::CACHE_CLASS][$className];}$this->cache[self::CACHE_CLASS][$className]=$this->backend->getClass($className);return$this->cache[self::CACHE_CLASS][$className];}public function getFunction($functionName){$functionName=ltrim($functionName,'\\');if(isset($this->cache[self::CACHE_FUNCTION][$functionName])){return$this->cache[self::CACHE_FUNCTION][$functionName];}if($function=$this->backend->getFunction($functionName)){$this->cache[self::CACHE_FUNCTION][$functionName]=$function;}return$function;}public function getConstant($constantName){$constantName=ltrim($constantName,'\\');if(isset($this->cache[self::CACHE_CONSTANT][$constantName])){return$this->cache[self::CACHE_CONSTANT][$constantName];}if($constant=$this->backend->getConstant($constantName)){$this->cache[self::CACHE_CONSTANT][$constantName]=$constant;}return$constant;}public function getFileTokens($fileName){if(!$this->backend->getStoringTokenStreams){throw new RuntimeException('Token streams storing is turned off.');}return$this->backend->getFileTokens($fileName);}public function getClasses($types=Backend::TOKENIZED_CLASSES){return$this->backend->getClasses($types);}}
 namespace TokenReflection;use Exception as InternalException;class Exception extends InternalException{const UNSUPPORTED=-1;const INVALID_SOURCE=0;const FILE_DOES_NOT_EXIST=1;const FILE_NOT_READABLE=2;const DIR_DOES_NOT_EXIST=3;const NO_BACKEND_SET=5;const UNSERIALIZATION_ERROR=10;const DOES_NOT_EXIST=15;}
 namespace TokenReflection;use Reflector;interface IReflection{public function getName();public function getBroker();public function isTokenized();public function isInternal();public function isUserDefined();public function __get($key);public function __isset($key);}
 namespace TokenReflection;class ReflectionAnnotation{const SHORT_DESCRIPTION='short_description';const LONG_DESCRIPTION='long_description';public static function parse(ReflectionBase$reflection){$docblock=$reflection->getInheritedDocComment();if(false ===$docblock){return array();}$docblock=array_map(function($line){return preg_replace('~^\\s*\\*\\s*~','',trim($line),1);},array_slice(preg_split('~[\\r\\n]+~',$docblock),1,-1));$result=array();$name=self::SHORT_DESCRIPTION;foreach($docblock as$line){if(preg_match('~^@\\s*([\\S]+)\\s*(.*)~',$line,$matches)){if(!isset($result['PARAMS'])){$result['PARAMS']=array();}$name=strtolower($matches[1]);if(!isset($result['PARAMS'][$name])){$result['PARAMS'][$name]=array();}$result['PARAMS'][$name][]=$matches[2];}else{if(empty($line)){if(self::SHORT_DESCRIPTION ===$name){$name=self::LONG_DESCRIPTION;continue;}else{$line="\n";}}if(self::SHORT_DESCRIPTION ===$name || self::LONG_DESCRIPTION ===$name){if(!isset($result[$name])){$result[$name]=$line;}else{$result[$name].= "\n".$line;}}else{if(is_array($result['PARAMS'][$name])){$index=count($result['PARAMS'][$name])-1;$result['PARAMS'][$name][$index].= ' '.trim($line);}else{$result['PARAMS'][$name].= ' '.trim($line);}}}}array_walk_recursive($result,function(&$value){$value=trim($value);});return$result;}}
 namespace TokenReflection;use ArrayIterator;use InvalidArgumentException,RuntimeException;class Stream extends ArrayIterator{private$filename='unknown';public function __construct(array$stream,$filename){parent::__construct($stream);$this->filename=$filename;}public function getTokenValue(){$token=$this->current();return$token[1];}public function offsetUnset($offset){throw new Exception('Removing of tokens from the stream is not supported.',Exception::UNSUPPORTED);}public function offsetSet($offset,$value){throw new Exception('Setting token values is not supported.',Exception::UNSUPPORTED);}public function getFileName(){return$this->filename;}public function getClassStream(){$type=$this->getType();if(T_CLASS !==$type &&T_INTERFACE !==$type){throw new InvalidArgumentException(sprintf('There is no T_CLASS nor T_INTERFACE keyword at position [%d] in file [%s]',$this->key(),$this->filename));}static$prefixes=array(T_COMMENT,T_WHITESPACE,T_ABSTRACT,T_FINAL,);$start=$this->key();while(in_array($this->getType($start-1),$prefixes,true)){$start--;}$start=$this->findPrecedingDocComment($ex=$start);if($ex ===$start){while($this->is(T_WHITESPACE,$start)){$start++;}}$this->next();while(null !==($type=$this->getType())&&'{' !==$type){$this->skipWhitespaces();}if('{' !==$type){throw new RuntimeException(sprintf('Could not find the beginning of the class/interface with keyword at position [%d] in file [%s]',$this->key(),$this->filename));}$this->findMatchingBracket();return new Stream(array_slice($this->getArrayCopy(),$start,$this->key()-$start+1),$this->filename);}public function getNamespaceStream(){if(!$this->is(T_NAMESPACE)){throw new InvalidArgumentException(sprintf('There is no T_NAMESPACE keyword at position [%d] in file [%s]',$this->key(),$this->filename));}$start=$this->findPrecedingDocComment($this->key());while(null !==($type=$this->getType())&&';' !==$type &&'{' !==$type){$this->skipWhitespaces();}if(';' ===$type){while(null !==($key=$this->key())&&(!$this->is(T_NAMESPACE,$key+1)||$this->is(T_NS_SEPARATOR,$key+2))){$this->next();}}elseif('{' ===$type){$this->findMatchingBracket();}else{throw new RuntimeException(sprintf('Could not find the beginning of the namespace with keywords at position [%d] in file [%s]',$end,$this->filename));}return new Stream(array_slice($this->getArrayCopy(),$start,($this->key()?:count($this)-1)-$start+1),$this->filename);}public function getFunctionStream(){if(!$this->is(T_FUNCTION)){throw new InvalidArgumentException(sprintf('There is no T_FUNCTION keyword at position [%d] in file [%s]',$this->key(),$this->filename));}$start=$this->findPrecedingDocComment($this->key());$this->next();while(null !==($type=$this->getType())&&';' !==$type &&'{' !==$type){$this->skipWhitespaces();}if('{' ===$type){$this->findMatchingBracket();}elseif(';' !==$type){throw new RuntimeException(sprintf('Could not find the beginning of the function body definition with keywords at position [%d] in file [%s]',$this->key(),$this->filename));}return new Stream(array_slice($this->getArrayCopy(),$start,$this->key()-$start+1),$this->filename);}public function getConstantStream(){if(!$this->is(T_STRING)){throw new InvalidArgumentException(sprintf('There is no T_STRING keyword at position [%d] in file [%s]',$this->key(),$this->filename));}static$prefixes=array(T_COMMENT,T_WHITESPACE,);$start=$this->key();while(in_array($type=$this->getType($start-1),$prefixes,true)){$start--;}if(T_CONST ===$type){$start=$this->findPrecedingDocComment($start-1);}else{$start=$this->key();}while(null !==($type=$this->getType())&&';' !==$type &&',' !==$type){$this->next();}if(';' !==$type &&',' !==$type){throw new RuntimeException(sprintf('Could not find the end of constant definition at position [%d] in file [%s]',$this->key(),$this->filename));}return new Stream(array_slice($this->getArrayCopy(),$start,$this->key()-$start+1),$this->filename);}public function getMethodStream(){if(!$this->is(T_FUNCTION)){throw new InvalidArgumentException(sprintf('There is no T_FUNCTION keyword at position [%d] in file [%s]',$this->key(),$this->filename));}$start=$this->key();static$acceptedPrevious=array(T_PUBLIC,T_PROTECTED,T_STATIC,T_PRIVATE,T_WHITESPACE,T_COMMENT,T_ABSTRACT,T_FINAL);while(null !==($type=$this->getType($start-1))&&in_array($type,$acceptedPrevious)){$start--;}$start=$this->findPrecedingDocComment($ex=$start);if($start ===$ex){while(null !==($type=$this->getType($start))&&(T_WHITESPACE ===$type || T_COMMENT ===$type)){$start++;}}$this->next();while(null !==($type=$this->getType())&&'{' !==$type &&';' !==$type){$this->next();}if('{' ===$type){$this->findMatchingBracket();}elseif(';' !==$type){throw new RuntimeException(sprintf('Could not find the beginning of the class method body definition with keywords at position [%d] in file [%s]',$this->key(),$this->filename));}return new Stream(array_slice($this->getArrayCopy(),$start,$this->key()-$start+1),$this->filename);}public function getParameterStream(){if(!$this->is(T_VARIABLE)){throw new InvalidArgumentException(sprintf('There is no T_VARIABLE keyword at position [%d] in file [%s]',$this->key(),$this->filename));}$start=$this->key();static$acceptedPrevious=array(T_WHITESPACE,T_COMMENT,T_ARRAY,T_STRING,T_NS_SEPARATOR,'&');while(null !==($type=$this->getType($start-1))&&in_array($type,$acceptedPrevious)){$start--;}while(null !==($type=$this->getType($start))&&T_WHITESPACE ===$type || T_COMMENT ===$type){$start++;}$this->next();while(null !==($type=$this->getType())&&',' !==$type &&')' !==$type){if('(' ===$type){$this->findMatchingBracket();}$this->next();}if(null ===$type){throw new RuntimeException(sprintf('Could not find the end of the parameter definition with keywords at position [%d] in file [%s]',$this->key(),$this->filename));}return new Stream(array_slice($this->getArrayCopy(),$start,$this->key()-$start),$this->filename);}public function getPropertyStream(){if(!$this->is(T_VARIABLE)){throw new InvalidArgumentException(sprintf('There is no T_VARIABLE keyword at position [%d] in file [%s]',$this->key(),$this->filename));}$start=$this->key();static$acceptedPrevious=array(T_PUBLIC,T_PROTECTED,T_STATIC,T_PRIVATE,T_WHITESPACE,T_COMMENT,T_VAR);while(null !==($type=$this->getType($start-1))&&in_array($type,$acceptedPrevious)){$start--;}$start=$this->findPrecedingDocComment($ex=$start);if($ex ===$start){while(null !==($type=$this->getType($start))&&(T_WHITESPACE ===$type || T_COMMENT ===$type)){$start++;}}$this->next();while(null !==($type=$this->getType())&&';' !==$type &&',' !==$type){if(T_ARRAY ===$type){$this->skipWhitespaces();$this->findMatchingBracket();}else{$this->next();}}if(';' !==$type &&',' !==$type){throw new RuntimeException(sprintf('Could not find the end of the class property definition with keywords at position [%d] in file [%s]',$this->key(),$this->filename));}return new Stream(array_slice($this->getArrayCopy(),$start,$this->key()-$start+1),$this->filename);}public function findPrecedingDocComment($position){$prev=$this->getType($position-1);if(T_DOC_COMMENT ===$prev){$position--;}elseif(T_WHITESPACE ===$prev &&T_DOC_COMMENT ===$this->getType($position-2)){$position -= 2;}return$position;}public function findMatchingBracket(){static$brackets=array('(' => ')','{' => '}','[' => ']');$position=$this->key();$bracket=$this->getType();if(isset($brackets[$bracket])){$searching=$brackets[$bracket];}else{throw new InvalidArgumentException(sprintf('There is no usable bracket at position [%d] in file [%s]',$this->key(),$this->filename));}$level=0;while(null !==($type=$this->getType())){if($bracket ===$type ||($searching === '}' &&(T_CURLY_OPEN ===$type || T_DOLLAR_OPEN_CURLY_BRACES ===$type))){$level++;}elseif($searching ===$type){$level--;}if(0 ===$level){return$this;}$this->next();}throw new RuntimeException(sprintf('Could not find the matching bracket "%s" of the bracket at position [%d] in file [%s]',$searching,$position,$this->filename));}public function skipWhitespaces($startAtNext=true){if($this->valid()&&$startAtNext){$this->next();}while(true){$type=$this->getType();if($type === T_WHITESPACE ||$type === T_COMMENT){$this->next();continue;}break;}}public function is($type,$position=-1){return$type ===$this->getType($position);}public function getType($position=-1){if(-1 ===$position){$token=$this->current();return$token[0];}else{return isset($this[$position])?$this[$position][0]:null;}}public function getTokenName($position=-1){$type=$this->getType($position);return@token_name($type)?:$type;}public function __toString(){return self::tokensToCode($this->getArrayCopy());}public static function tokensToCode($tokens){if(!is_array($tokens)&&(!is_object($tokens)||!$tokens instanceof Traversable)){throw new InvalidArgumentException('You have to provide an array or an iterateable list of tokens');}$source='';foreach($tokens as$token){$source .=$token[1];}return$source;}}
 namespace TokenReflection\Broker\Backend;use TokenReflection\Broker\Backend as IBackend,TokenReflection\Broker as BrokerParent,TokenReflection\ReflectionFile,TokenReflection\ReflectionNamespace;use TokenReflection\Php\ReflectionFunction as ReflectionPhpFunction,TokenReflection\Php\ReflectionConstant as ReflectionPhpConstant;use TokenReflection\Php\ReflectionClass as ReflectionPhpClass,TokenReflection\Dummy\ReflectionClass as ReflectionDummyClass;use InvalidArgumentException,TokenReflection\Exception;class Memory implements IBackend{private$namespaces=array();private$allClasses;private$tokenStreams=array();private$broker;private$storingTokenStreams;public function getNamespace($namespaceName){if(!isset($this->namespaces[ReflectionNamespace::NO_NAMESPACE_NAME])){$this->namespaces[ReflectionNamespace::NO_NAMESPACE_NAME]=new ReflectionNamespace(ReflectionNamespace::NO_NAMESPACE_NAME,$this->broker);}$namespaceName=ltrim($namespaceName,'\\');if(!isset($this->namespaces[$namespaceName])){throw new Exception(sprintf('Namespace %s does not exist.',$namespaceName),Exception::DOES_NOT_EXIST);}return$this->namespaces[$namespaceName];}public function getClass($className){static$declared=array();if(empty($declared)){$declared=array_flip(array_merge(get_declared_classes(),get_declared_interfaces()));}$className=ltrim($className,'\\');try{$ns=$this->getNamespace(($boundary=strrpos($className,'\\'))?substr($className,0,$boundary):ReflectionNamespace::NO_NAMESPACE_NAME);return$ns->getClass($className);}catch(Exception$e){return isset($declared[$className])?new ReflectionPhpClass($className,$this->broker):new ReflectionDummyClass($className,$this->broker);}}public function getFunction($functionName){static$declared=array();if(empty($declared)){$functions=get_defined_functions();$declared=array_flip(array_merge($functions['internal'],$functions['user']));}$functionName=ltrim($functionName,'\\');try{$ns=$this->getNamespace(($boundary=strrpos($functionName,'\\'))?substr($functionName,0,$boundary):ReflectionNamespace::NO_NAMESPACE_NAME);return$ns->getFunction($functionName);}catch(Exception$e){return isset($declared[$functionName])?new ReflectionPhpFunction($functionName,$this->broker):null;}}public function getConstant($constantName){static$declared=array();if(empty($declared)){$declared=get_defined_constants();}if($boundary=strpos($constantName,'::')){$className=substr($constantName,0,$boundary);$constantName=substr($constantName,$boundary+2);try{return$this->getClass($className)->getConstantReflection($constantName);}catch(Exception$e){return null;}}try{$constantName=ltrim($constantName,'\\');if($boundary=strrpos($constantName,'\\')){$ns=$this->getNamespace(substr($constantName,0,$boundary));$constantName=substr($constantName,$boundary+1);}else{$ns=$this->getNamespace(ReflectionNamespace::NO_NAMESPACE_NAME);}return$ns->getConstant($constantName);}catch(Exception$e){return isset($declared[$constantName])?new ReflectionPhpConstant($constantName,$declared[$constantName],$this->broker):null;}}public function isFileProcessed($fileName){return isset($this->tokenStreams[$fileName]);}public function getFileTokens($fileName){if(!$this->isFileProcessed($fileName)){throw new InvalidArgumentException(sprintf('File %s was not processed',$fileName));}return$this->tokenStreams[$fileName];}public function addFile(ReflectionFile$file,$storeTokenStream=true){foreach($file->getNamespaces()as$namespaceName =>$fileNamespace){if(!isset($this->namespaces[$namespaceName])){$this->namespaces[$namespaceName]=new ReflectionNamespace($namespaceName,$file->getBroker());}$this->namespaces[$namespaceName]->addFileNamespace($fileNamespace);}if($this->storingTokenStreams){$this->tokenStreams[$file->getName()]=$file->getTokenStream();}$this->allClasses=null;return$this;}public function setBroker(BrokerParent$broker){$this->broker=$broker;return$this;}public function getBroker(){return$this->broker;}public function setStoringTokenStreams($store){$this->storingTokenStreams=(bool)$store;return$this;}public function getStoringTokenStreams(){return$this->storingTokenStreams;}protected function parseClassLists(){$allClasses=array(IBackend::TOKENIZED_CLASSES => array(),IBackend::INTERNAL_CLASSES => array(),IBackend::NONEXISTENT_CLASSES => array());foreach($this->namespaces as$namespace){foreach($namespace->getClasses()as$class){$allClasses[IBackend::TOKENIZED_CLASSES][$class->getName()]=$class;foreach(array_merge($class->getParentClasses(),$class->getInterfaces())as$parent){if($parent->isInternal()){$allClasses[IBackend::INTERNAL_CLASSES][$parent->getName()]=$parent;}elseif(!$parent->isUserDefined()){$allClasses[IBackend::NONEXISTENT_CLASSES][$parent->getName()]=$parent;}}}}return$allClasses;}public function getClasses($type=IBackend::TOKENIZED_CLASSES){if(null ===$this->allClasses){$this->allClasses=$this->parseClassLists();}$result=array();foreach($this->allClasses as$classType =>$classes){if($type&$classType){$result=array_merge($result,$classes);}}return$result;}}
 namespace TokenReflection;interface IReflectionClass extends IReflection{public function getConstant($name);public function getConstantReflection($name);public function getConstants();public function getOwnConstants();public function getConstantReflections();public function getOwnConstantReflections();public function getConstructor();public function getDestructor();public function getDefaultProperties();public function getDocComment();public function getInheritedDocComment();public function getStartLine();public function getEndLine();public function getExtension();public function getExtensionName();public function getFileName();public function getInterfaceNames();public function getOwnInterfaceNames();public function getInterfaces();public function getOwnInterfaces();public function getMethod($name);public function getMethods($filter=null);public function getOwnMethods($filter=null);public function getModifiers();public function getNamespaceName();public function getParentClass();public function getParentClasses();public function getParentClassName();public function getParentClassNameList();public function getProperties($filter=null);public function getOwnProperties($filter=null);public function getProperty($name);public function getShortName();public function getStaticProperties();public function getStaticPropertyValue($name,$default=null);public function hasConstant($name);public function hasOwnConstant($name);public function hasMethod($name);public function hasOwnMethod($name);public function hasProperty($name);public function hasOwnProperty($name);public function implementsInterface($interface);public function inNamespace();public function isAbstract();public function isFinal();public function isInstance($object);public function isInterface();public function isCloneable();public function isIterateable();public function isSubclassOf($class);public function getDirectSubclasses();public function getDirectSubclassNames();public function getIndirectSubclasses();public function getIndirectSubclassNames();public function getDirectImplementers();public function getDirectImplementerNames();public function getIndirectImplementers();public function getIndirectImplementerNames();public function newInstance($args);public function newInstanceArgs(array$args=array());public function setStaticPropertyValue($name,$value);}
 namespace TokenReflection;interface IReflectionConstant extends IReflection{public function getDeclaringClass();public function getDeclaringClassName();public function getNamespaceName();public function inNamespace();public function getValue();public function getValueDefinition();public function getDocComment();public function getInheritedDocComment();public function getStartLine();public function getEndLine();public function getFileName();public function getShortName();}
 namespace TokenReflection;interface IReflectionExtension extends IReflection{public function getClass($name);public function getClasses();public function getClassNames();public function getConstantReflection($name);public function getConstantReflections();public function getConstant($name);public function getConstants();public function getFunction($name);public function getFunctions();public function getFunctionNames();}
 namespace TokenReflection;interface IReflectionFunctionBase extends IReflection{public function getDocComment();public function getInheritedDocComment();public function getStartLine();public function getEndLine();public function getExtension();public function getExtensionName();public function getFileName();public function getNamespaceName();public function getNumberOfParameters();public function getNumberOfRequiredParameters();public function getParameters();public function getParameter($parameter);public function getStaticVariables();public function inNamespace();public function isClosure();public function isDeprecated();public function returnsReference();}
 namespace TokenReflection;interface IReflectionNamespace extends IReflection{public function getClass($className);public function getClasses();public function getClassNames();public function getClassShortNames();public function getFunction($functionName);public function getFunctions();public function getFunctionNames();public function getFunctionShortNames();public function getConstant($constantName);public function getConstants();public function getConstantNames();public function getConstantShortNames();}
 namespace TokenReflection;interface IReflectionParameter extends IReflection{public function getDeclaringClass();public function getDeclaringClassName();public function getDeclaringFunction();public function getDeclaringFunctionName();public function getDefaultValue();public function getDefaultValueDefinition();public function getPosition();public function isArray();public function allowsNull();public function getClass();public function getClassName();public function isDefaultValueAvailable();public function isOptional();public function isPassedByReference();public function getDocComment();public function getInheritedDocComment();public function getStartLine();public function getEndLine();}
 namespace TokenReflection;interface IReflectionProperty extends IReflection{public function getDeclaringClass();public function getClass();public function getDeclaringClassName();public function getDocComment();public function getInheritedDocComment();public function getStartLine();public function getEndLine();public function getModifiers();public function getValue($object);public function isDefault();public function getDefaultValue();public function getDefaultValueDefinition();public function isPrivate();public function isProtected();public function isPublic();public function isStatic();public function setAccessible($accessible);public function setValue($object,$value);}
 namespace TokenReflection\Php;use TokenReflection\IReflection as ParentIReflection,TokenReflection\Broker;use Reflector;interface IReflection extends ParentIReflection{public static function create(Reflector$internalReflection,Broker$broker);}
 namespace TokenReflection;use RuntimeException;abstract class ReflectionBase implements IReflection{private static$methodCache=array();private$broker;private$startLine;private$endLine;private$docComment;private$parsedDocComment;protected$name;private$filename;public final function __construct(Stream$tokenStream,Broker$broker,IReflection$parent){if(0 === count($tokenStream)){throw new Exception('Reflection token stream must not be empty');}$this->broker=$broker;$this->filename=$tokenStream->getFileName();return$this ->processParent($parent)->parse($tokenStream,$parent)->parseChildren($tokenStream);}protected function processParent(IReflection$parent){return$this;}protected function parseChildren(Stream$tokenStream){return$this;}protected function parse(Stream$tokenStream,IReflection$parent){return$this ->parseDocComment($tokenStream)->parseBoundaries($tokenStream);}private function parseDocComment(Stream$tokenStream){if(!$tokenStream->is(T_DOC_COMMENT)){$this->docComment=false;}else{$this->docComment=$tokenStream->getTokenValue();$tokenStream->skipWhitespaces();}return$this;}private function parseBoundaries(Stream$tokenStream){$tmp=null;$this->startLine=$tokenStream[0][2];if($this->docComment){$this->startLine += preg_match_all('~[\\n\\r]~',$this->docComment,$tmp)+1;}if($last=count($tokenStream)){$this->endLine=$tokenStream[--$last][2]+preg_match_all('~[\\n\\r]~',$tokenStream[$last][1],$tmp);}return$this;}abstract protected function parseName(Stream$tokenStream);public function getFileName(){return$this->filename;}public function getStartLine(){return$this->startLine;}public function getEndLine(){return$this->endLine;}public function getExtension(){return null;}public function getExtensionName(){return null;}public function isInternal(){return false;}public function isUserDefined(){return true;}public function isDeprecated(){return$this->hasAnnotation('deprecated');}public function getName(){return$this->name;}public function getSource(){$tokens=$this->broker->getFileTokens($this->filename);if(null !==$tokens &&$tokens instanceof Stream){$tokens=iterator_to_array($tokens);}else{return '';}return array_reduce($tokens,function($output,$token){return$output.$token[1];},'');}public function getDocComment(){return$this->docComment;}public function getBroker(){return$this->broker;}public function isTokenized(){return true;}public function __toString(){return '';}private function parseAnnotations(){$this->parsedDocComment=ReflectionAnnotation::parse($this);}public function getPackageName(){if($package=$this->getAnnotation('package')){return$package[0];}return ReflectionClass::PACKAGE_NONE;}final public function getAnnotation($name){$name=strtolower($name);$params=$this->getAnnotations();if(isset($params[$name])){return$params[$name];}return isset($this->parsedDocComment[$name])?$this->parsedDocComment[$name]:null;}final public function hasAnnotation($name){$name=strtolower($name);$params=$this->getAnnotations();if(isset($params[$name])){return true;}return isset($this->parsedDocComment[$name]);}final public function getAnnotations(){if(null ===$this->parsedDocComment){$this->parseAnnotations();}return isset($this->parsedDocComment['PARAMS'])?$this->parsedDocComment['PARAMS']:array();}final public function __get($key){return self::get($this,$key);}final public function __isset($key){return self::exists($this,$key);}public static function export($argument,$return=false){}final public static function get(IReflection$object,$key){if(!empty($key)){$className=get_class($object);if(!isset(self::$methodCache[$className])){self::$methodCache[$className]=array_flip(get_class_methods($className));}$methods=self::$methodCache[$className];$key2=ucfirst($key);if(isset($methods['get'.$key2])){return$object->{'get'.$key2}();}elseif(isset($methods['is'.$key2])){return$object->{'is'.$key2}();}}throw new RuntimeException(sprintf('Cannot read property %s',$key));}final public static function exists(IReflection$object,$key){try{self::get($object,$key);return true;}catch(RuntimeException$e){return false;}}final public static function resolveClassFQN($className,array$aliases,$namespaceName=null){if($className{0}== '\\'){return ltrim($className,'\\');}if(false ===($position=strpos($className,'\\'))){if(isset($aliases[$className])){return$aliases[$className];}}else{$alias=substr($className,0,$position);if(isset($aliases[$alias])){return$aliases[$alias].'\\'.substr($className,$position+1);}}return null ===$namespaceName ||$namespaceName === ReflectionNamespace::NO_NAMESPACE_NAME?$className:$namespaceName.'\\'.$className;}}
 namespace TokenReflection;use ArrayIterator;class ReflectionFile implements IReflection{private$namespaces=array();private$tokenStream=null;private$broker;public function __construct($filename,array$tokenStream,Broker$broker){$this->tokenStream=new Stream($tokenStream,$filename);$this->broker=$broker;$this->parse();}public function getNamespaces(){return$this->namespaces;}private function parse(){if(count($this->tokenStream)<= 1){return;}static$breakers=array(T_CLASS,T_INTERFACE,T_FUNCTION,T_CONST,T_IF);while(null !==($type=$this->tokenStream->getType())){if(in_array($type,$breakers)){break;}if(T_NAMESPACE ===$type){$namespace=new ReflectionFileNamespace($this->tokenStream->getNamespaceStream(),$this->broker,$this);$this->namespaces[$namespace->getName()]=$namespace;}$this->tokenStream->skipWhitespaces();}if(empty($this->namespaces)){for($nsStart=0;$nsStart <=$this->tokenStream->key();$nsStart++){if($this->tokenStream->is(T_OPEN_TAG,$nsStart)){break;}}while(null !==($this->tokenStream->getType($nsStart+1))&&T_DOC_COMMENT ===$this->tokenStream->getType($nsStart)&&T_WHITESPACE ===$type){$nsStart += 2;}$tokens=$this->tokenStream->getArrayCopy();$namespace=new ReflectionFileNamespace(new Stream(array_slice($tokens,$nsStart),$this->tokenStream->getFileName()),$this->broker,$this);$this->namespaces[$namespace->getName()]=$namespace;}}public function getTokenStream(){return$this->tokenStream;}public function getName(){return$this->tokenStream->getFileName();}public function getBroker(){return$this->broker;}public function __toString(){return '';}public function getSource(){return (string)$this->tokenStream;}public static function export($argument,$return=false){return ReflectionBase::export($argument,$return);}public function isTokenized(){return true;}public function isInternal(){return false;}public function isUserDefined(){return true;}final public function __get($key){return ReflectionBase::get($this,$key);}final public function __isset($key){return ReflectionBase::exists($this,$key);}}
 namespace TokenReflection;use ReflectionProperty as InternalReflectionProperty,ReflectionClass as InternalReflectionClass;use RuntimeException,InvalidArgumentException;class ReflectionProperty extends ReflectionBase implements IReflectionProperty{const IS_SHADOW=0x20000;private static$parseValueDefinitions=false;private$declaringClassName;private$defaultValue;private$defaultValueDefinition;private$modifiers=0;private$accessible=false;public function getDeclaringClassName(){return$this->declaringClassName;}public function getClass(){return$this->getDeclaringClassName();}public function getDeclaringClass(){return$this->getBroker()->getClass($this->declaringClassName);}public function getModifiers(){if(!($this->modifiers&self::IS_SHADOW)){$declaringClass=$this->getDeclaringClass();if(null ===$declaringClass){throw new RuntimeException('No declaring class defined.');}$parentClass=$declaringClass->getParentClass();if(null !==$parentClass){$parentClassProperties=$parentClass->getProperties(InternalReflectionProperty::IS_PRIVATE);if(isset($parentClassProperties[$this->name])){$this->modifiers |= self::IS_SHADOW;}}}return$this->modifiers;}public function isDefault(){return null !==$this->defaultValueDefinition;}public function getDefaultValue(){return$this->defaultValue;}public function getValue($object){$declaringClass=$this->getDeclaringClass();if(null ===$declaringClass){throw new RuntimeException('No declaring class defined.');}if(!$declaringClass->isInstance($object)){throw new InvalidArgumentException(sprintf('Invalid class, %s expected %s given',$declaringClass->getName(),get_class($object)));}if($this->isPublic()){return$object->{$this->name};}elseif($this->isAccessible()){$refClass=new InternalReflectionClass($object);$refProperty=$refClass->getProperty($this->name);$refProperty->setAccessible(true);$value=$refProperty->getValue($object);$refProperty->setAccessible(false);return$value;}throw new Exception('Only public or accessible properties can return thier values');}public function getDefaultValueDefinition(){return$this->defaultValueDefinition;}public function isPrivate(){return (bool)($this->modifiers&InternalReflectionProperty::IS_PRIVATE);}public function isProtected(){return (bool)($this->modifiers&InternalReflectionProperty::IS_PROTECTED);}public function isPublic(){return (bool)($this->modifiers&InternalReflectionProperty::IS_PUBLIC);}public function isStatic(){return (bool)($this->modifiers&InternalReflectionProperty::IS_STATIC);}public function setAccessible($accessible){$this->accessible=(bool)$accessible;}public function isAccessible(){return$this->accessible;}public function getInheritedDocComment(){if(false !==($docComment=$this->getDocComment())){return$docComment;}$parent=$this->getDeclaringClass()->getParentClass();if(null !==$parent &&$parent->hasProperty($this->getName())){return$parent->getProperty($this->getName())->getInheritedDocComment();}return false;}public function setValue($object,$value){$declaringClass=$this->getDeclaringClass();if(null ===$declaringClass){throw new RuntimeException('No declaring class defined.');}if(!$declaringClass->isInstance($object)){throw new InvalidArgumentException(sprintf('Invalid class, %s expected %s given',$declaringClass->getName(),get_class($object)));}if($this->isPublic()){$object->{$this->name}=$value;}elseif($this->isAccessible()){$refClass=new InternalReflectionClass($object);$refProperty=$refClass->getProperty($this->name);$refProperty->setAccessible(true);$refProperty->setValue($object,$value);$refProperty->setAccessible(false);if($this->isStatic()){$this->defaultValue=$value;$this->defaultValueDefinition=null;}}else{throw new Exception('Only public or accessible properties can set');}}public function setDefaultValue($value){$this->defaultValue=$value;}protected function processParent(IReflection$parent){if(!$parent instanceof ReflectionClass){throw new InvalidArgumentException(sprintf('The parent reflection object has to be a TokenReflection\ReflectionClass instance, %s given',get_class($parent)));}$this->declaringClassName=$parent->getName();return parent::processParent($parent);}protected function parse(Stream$tokenStream,IReflection$parent){return parent::parse($tokenStream,$parent)->parseModifiers($tokenStream,$parent)->parseName($tokenStream)->parseDefaultValue($tokenStream);}protected function parseName(Stream$tokenStream){if(!$tokenStream->is(T_VARIABLE)){throw new RuntimeException(sprintf('Unexpected token %s; T_VARIABLE expected',$tokenStream->getTokenName()));}$token=$tokenStream->current();$this->name=substr($token[1],1);$tokenStream->skipWhitespaces();return$this;}private function parseDefaultValue(Stream$tokenStream){$type=$tokenStream->getType();if(';' ===$type || ',' ===$type){return$this;}$lastType=$tokenStream->getType(count($tokenStream)-1);if(';' !==$lastType &&',' !==$lastType){throw new RuntimeException('Property definition is not terminated properly');}if('=' !==$type){throw new RuntimeException(sprintf('Unexpected token %s; "=" expected.',$tokenStream->getTokenName()));}$tokenStream->skipWhitespaces();$this->defaultValueDefinition=Stream::tokensToCode(array_slice($tokenStream->getArrayCopy(),$tokenStream->key(),-1));if(self::$parseValueDefinitions){$this->defaultValue=@eval('return '.$this->defaultValueDefinition.';');}return$this;}private function parseModifiers(Stream$tokenStream,ReflectionClass$class){while(true){switch($tokenStream->getType()){case T_PUBLIC:case T_VAR:$this->modifiers |= InternalReflectionProperty::IS_PUBLIC;break;case T_PROTECTED:$this->modifiers |= InternalReflectionProperty::IS_PROTECTED;break;case T_PRIVATE:$this->modifiers |= InternalReflectionProperty::IS_PRIVATE;break;case T_STATIC:$this->modifiers |= InternalReflectionProperty::IS_STATIC;break;default:break 2;}$tokenStream->skipWhitespaces();}if(!($this->modifiers&(InternalReflectionProperty::IS_PRIVATE|InternalReflectionProperty::IS_PROTECTED|InternalReflectionProperty::IS_PUBLIC))){$parentProperties=$class->getOwnProperties();if(empty($parentProperties)){throw new RuntimeException('No access level defined and no previous defining class property present.');}$sibling=array_pop($parentProperties);if($sibling->isPublic()){$this->modifiers |= InternalReflectionProperty::IS_PUBLIC;}elseif($sibling->isPrivate()){$this->modifiers |= InternalReflectionProperty::IS_PRIVATE;}elseif($sibling->isProtected()){$this->modifiers |= InternalReflectionProperty::IS_PROTECTED;}else{throw new RuntimeException(sprintf('Property sibling %s has no access level defined.',$sibling->getName()));}if($sibling->isStatic()){$this->modifiers |= InternalReflectionProperty::IS_STATIC;}}return$this;}public static function setParseValueDefinitions($parse){self::$parseValueDefinitions=(bool)$parse;}public static function getParseValueDefinitions(){return self::$parseValueDefinitions;}}
 namespace TokenReflection\Dummy;use TokenReflection\IReflectionClass,TokenReflection\Broker,TokenReflection\Exception,TokenReflection\ReflectionBase,TokenReflection\Broker\Backend;use ReflectionClass as InternalReflectionClass;class ReflectionClass implements IReflectionClass{const PACKAGE_NONE='None';private$broker;private$name;public function __construct($className,Broker$broker){$this->name=$className;$this->broker=$broker;}public function getName(){return$this->name;}public function getShortName(){$pos=strrpos($this->name,'\\');return false ===$pos?$this->name:substr($this->name,$pos+1);}public function getBroker(){return$this->broker;}public function getPackageName(){return self::PACKAGE_NONE;}final public function __get($key){return ReflectionBase::get($this,$key);}final public function __isset($key){return ReflectionBase::exists($this,$key);}public function getFileName(){return null;}public function getStartLine(){return null;}public function getEndLine(){return null;}public function getExtension(){return null;}public function getExtensionName(){return null;}public function isInternal(){return false;}public function isUserDefined(){return false;}public function getSource(){return '';}public function getDocComment(){return false;}public function getInheritedDocComment(){return$this->getDocComment();}public function __toString(){return '';}public function getAnnotations(){return array();}public function getAnnotation($name){return null;}public function hasAnnotation($name){return false;}public function getConstant($name){throw new Exception(sprintf('Constant "%s" is not defined in class "%s"',$name,$this->name),Exception::DOES_NOT_EXIST);}public function getConstantReflection($name){return array();}public function getConstants(){return array();}public function getConstantReflections(){return array();}public function getOwnConstantReflections(){return array();}public function getConstructor(){return null;}public function getDestructor(){return null;}public function getDefaultProperties(){return array();}public function getInterfaceNames(){return array();}public function getInterfaces(){return array();}public function getMethod($name){throw new Exception(sprintf('There is no method %s in class %s',$name,$this->name),Exception::DOES_NOT_EXIST);}public function getMethods($filter=null){return array();}public function getModifiers(){return 0;}public function getNamespaceName(){return null;}public function getParentClass(){return null;}public function getParentClasses(){return array();}public function getParentClassNameList(){return array();}public function getParentClassName(){return null;}public function getProperties($filter=null){return array();}public function getProperty($name){throw new Exception(sprintf('There is no property %s in class %s',$name,$this->name),Exception::DOES_NOT_EXIST);}public function getStaticProperties(){return array();}public function getStaticPropertyValue($name,$default=null){throw new Exception(sprintf('There is no static property %s in class %s',$name,$this->name),Exception::DOES_NOT_EXIST);}public function getOwnInterfaces(){return array();}public function getOwnInterfaceNames(){return array();}public function getOwnMethods($filter=null){return array();}public function getOwnProperties($filter=null){return array();}public function getOwnConstants(){return array();}public function hasConstant($name){return false;}public function hasOwnConstant($name){return false;}public function hasMethod($name){return false;}public function hasOwnMethod($name){return false;}public function hasProperty($name){return false;}public function hasOwnProperty($name){return false;}public function implementsInterface($interface){if(is_object($interface)){if(!$interface instanceof IReflectionClass){throw new InvalidArgumentException('Parameter must be a string or an instance of class reflection');}$interfaceName=$interface->getName();if(!$interface->isInterface()){throw new RuntimeException(sprintf('%s is not an interface.',$interfaceName));}}return false;}public function inNamespace(){return false;}public function isAbstract(){return false;}public function isFinal(){return false;}public function isTokenized(){return false;}public function isInstance($object){if(!is_object($object)){throw new Exception(sprintf('A class instance must be provided (%s set)',gettype($object)));}return$this->name === get_class($object)|| is_subclass_of($object,$this->name);}public function isInstantiable(){return false;}public function isCloneable(){return false;}public function isInterface(){return false;}public function isException(){return false;}public function isIterateable(){return false;}public function isSubclassOf($class){return false;}public function getDirectSubclasses(){$that=$this->name;return array_filter($this->getBroker()->getClasses(Backend::INTERNAL_CLASSES|Backend::TOKENIZED_CLASSES),function(IReflectionClass$class)use($that){if(!$class->isSubclassOf($that)){return false;}return null ===$class->getParentClassName()||!$class->getParentClass()->isSubClassOf($that);});}public function getDirectSubclassNames(){return array_keys($this->getDirectSubclasses());}public function getIndirectSubclasses(){$that=$this->name;return array_filter($this->getBroker()->getClasses(Backend::INTERNAL_CLASSES|Backend::TOKENIZED_CLASSES),function(IReflectionClass$class)use($that){if(!$class->isSubclassOf($that)){return false;}return null !==$class->getParentClassName()&&$class->getParentClass()->isSubClassOf($that);});}public function getIndirectSubclassNames(){return array_keys($this->getIndirectSubclasses());}public function getDirectImplementers(){if(!$this->isInterface()){return array();}$that=$this->name;return array_filter($this->getBroker()->getClasses(Backend::INTERNAL_CLASSES|Backend::TOKENIZED_CLASSES),function(IReflectionClass$class)use($that){if(!$class->implementsInterface($that)){return false;}return null ===$class->getParentClassName()||!$class->getParentClass()->implementsInterface($that);});}public function getDirectImplementerNames(){return array_keys($this->getDirectImplementers());}public function getIndirectImplementers(){if(!$this->isInterface()){return array();}$that=$this->name;return array_filter($this->getBroker()->getClasses(Backend::INTERNAL_CLASSES|Backend::TOKENIZED_CLASSES),function(IReflectionClass$class)use($that){if(!$class->implementsInterface($that)){return false;}return null !==$class->getParentClassName()&&$class->getParentClass()->implementsInterface($this);});}public function getIndirectImplementerNames(){return array_keys($this->getIndirectImplementers());}public function newInstance($args){return$this->newInstanceArgs(func_get_args());}public function newInstanceArgs(array$args=array()){if(!class_exists($this->name,true)){throw new Exception(sprintf('Could not create an instance of class %s; class not found',$this->name));}$reflection=new InternalReflectionClass($this->name);return$reflection->newInstanceArgs($args);}public function setStaticPropertyValue($name,$value){throw new Exception(sprintf('There is no static property %s in class %s',$name,$this->name),Exception::DOES_NOT_EXIST);}}
 namespace TokenReflection;interface IReflectionFunction extends IReflectionFunctionBase{public function isDisabled();public function invoke();public function invokeArgs(array$args);}
 namespace TokenReflection;interface IReflectionMethod extends IReflectionFunctionBase{public function getDeclaringClass();public function getClass();public function getDeclaringClassName();public function getModifiers();public function getPrototype();public function invoke($object,$args);public function invokeArgs($object,array$args);public function isAbstract();public function isConstructor();public function isDestructor();public function isFinal();public function isPrivate();public function isProtected();public function isPublic();public function isStatic();public function setAccessible($accessible);}
 namespace TokenReflection\Php;use TokenReflection\IReflectionClass,TokenReflection\Exception,TokenReflection\Broker,TokenReflection\ReflectionBase,TokenReflection\Broker\Backend;use Reflector,ReflectionClass as InternalReflectionClass,ReflectionProperty as InternalReflectionProperty,ReflectionMethod as InternalReflectionMethod;use RuntimeException;class ReflectionClass extends InternalReflectionClass implements IReflection,IReflectionClass{const PACKAGE_INTERNAL='PHP';private$broker;private$contants;private$methods;private$interfaces;private$properties;public function __construct($className,Broker$broker){parent::__construct($className);$this->broker=$broker;}public function getBroker(){return$this->broker;}public function getParentClass(){$parent=parent::getParentClass();return$parent?self::create($parent,$this->broker):$parent;}public function getParentClassName(){$parent=$this->getParentClass();return$parent?$parent->getName():$parent;}public function getParentClasses(){$broker=$this->broker;return array_map(function($className)use($broker){return$broker->getClass($className);},$this->getParentClassNameList());}public function getConstantReflection($name){if($this->hasConstant($name)){return new ReflectionConstant($name,$this->getConstant($name),$this->broker,$this);}throw new Exception(sprintf('Constant "%s" is not defined in class "%s"',$name,$this->getName()),Exception::DOES_NOT_EXIST);}public function getConstantReflections(){if(null ===$this->contants){$this->contants=array();foreach($this->getConstants()as$name =>$value){$this->contants[$name]=$this->getConstantReflection($name);}}return$this->contants;}public function getOwnConstantReflections(){if(null ===$this->contants){$this->contants=array();foreach($this->getOwnConstants()as$name =>$value){$this->contants[$name]=$this->getConstantReflection($name);}}return$this->contants;}public function getParentClassNameList(){return class_parents($this->getName());}public function getPackageName(){return$this->isInternal()?self::PACKAGE_INTERNAL:TokenReflection\ReflectionClass::PACKAGE_NONE;}final public function __get($key){return ReflectionBase::get($this,$key);}final public function __isset($key){return ReflectionBase::exists($this,$key);}public function getOwnInterfaces(){$parent=$this->getParentClass();return$parent?array_diff_key($this->getInterfaces(),$parent->getInterfaces()):$this->getInterfaces();}public function getOwnInterfaceNames(){return array_keys($this->getOwnInterfaces());}public function getOwnMethods($filter=null){$me=$this->getName();return array_filter($this->getMethods($filter),function(ReflectionMethod$method)use($me){return$method->declaringClass->name ===$me;});}public function hasOwnMethod($name){$methods=$this->getOwnMethods();return isset($methods[$name]);}public function getOwnProperties($filter=null){$me=$this->getName();return array_filter($this->getProperties($filter),function(ReflectionProperty$property)use($me){return$property->declaringClass->name ===$me;});}public function hasOwnProperty($name){$properties=$this->getOwnProperties();return isset($properties[$name]);}public function getOwnConstants(){return array_diff_assoc($this->getConstants(),$this->getParentClass()?$this->getParentClass()->getConstants():array());}public function hasOwnConstant($name){$constants=$this->getOwnConstants();return isset($constants[$name]);}public function getProperties($filter=null){if(null ===$this->properties){$broker=$this->broker;$this->properties=array_map(function(InternalReflectionProperty$property)use($broker){return ReflectionProperty::create($property,$broker);},parent::getProperties());}if(null ===$filter){return$this->properties;}else{return array_filter($this->properties,function(ReflectionProperty$property)use($filter){return (bool)($property->getModifiers()&$filter);});}}public function getMethods($filter=null){if(null ===$this->methods){$broker=$this->broker;$this->methods=array_map(function(InternalReflectionMethod$method)use($broker){return ReflectionMethod::create($method,$broker);},parent::getMethods());}if(null ===$filter){return$this->methods;}else{return array_filter($this->methods,function(ReflectionMethod$method)use($filter){return (bool)($method->getModifiers()&$filter);});}}public function getConstructor(){return ReflectionMethod::create(parent::getConstructor(),$this->broker);}public function getDestructor(){foreach($this->getMethods()as$method){if($method->isDestructor()){return$method;}}}public function getExtension(){return ReflectionExtension::create(parent::getExtension(),$this->broker);}public function isCloneable(){if(!$this->isInstantiable()){return false;}$methods=$this->getMethods();return isset($methods['__clone'])?$methods['__clone']->isPublic():true;}public function isException(){return 'Exception' ===$this->getName()||$this->isSubclassOf('Exception');}public function getInterfaces(){if(null ===$this->interfaces){$broker=$this->broker;$this->interfaces=array_map(function($interfaceName)use($broker){return$broker->getClass($interfaceName);},$this->getInterfaceNames());}return$this->interfaces;}public function implementsInterface($interface){if(is_object($interface)){if($interface instanceof InternalReflectionClass ||$interface instanceof IReflectionClass){$interfaceName=$interface->getName();}else{throw new InvalidArgumentException('Parameter must be a string or an instance of class reflection');}}else{$interfaceName=$interface;}$interfaces=$this->getInterfaces();return isset($interfaces[$interfaceName]);}public function getMethod($name){foreach($this->getMethods()as$method){if($method->getName()===$name){return$method;}}throw new Exception(sprintf('There is no method %s in class %s',$name,$this->name),Exception::DOES_NOT_EXIST);}public function getProperty($name){foreach($this->getProperties()as$property){if($name ===$property->getName()){return$property;}}throw new Exception(sprintf('There is no property %s in class %s',$name,$this->getName()),Exception::DOES_NOT_EXIST);}public function getStaticProperties(){return$this->getProperties(InternalReflectionProperty::IS_STATIC);}public function getInheritedDocComment(){if(false !==($docComment=$this->getDocComment())){return$docComment;}if($parent=$this->getParentClass()){return$parent->getInheritedDocComment();}return false;}public function getAnnotations(){return array();}public function getAnnotation($name){return null;}public function hasAnnotation($name){return false;}public function isSubclassOf($class){return in_array($class,$this->getParentClassNameList());}public function isTokenized(){return false;}public function getDirectSubclasses(){$that=$this->name;return array_filter($this->getBroker()->getClasses(Backend::INTERNAL_CLASSES|Backend::TOKENIZED_CLASSES),function(IReflectionClass$class)use($that){if(!$class->isSubclassOf($that)){return false;}return null ===$class->getParentClassName()||!$class->getParentClass()->isSubClassOf($that);});}public function getDirectSubclassNames(){return array_keys($this->getDirectSubclasses());}public function getIndirectSubclasses(){$that=$this->name;return array_filter($this->getBroker()->getClasses(Backend::INTERNAL_CLASSES|Backend::TOKENIZED_CLASSES),function(IReflectionClass$class)use($that){if(!$class->isSubclassOf($that)){return false;}return null !==$class->getParentClassName()&&$class->getParentClass()->isSubClassOf($that);});}public function getIndirectSubclassNames(){return array_keys($this->getIndirectSubclasses());}public function getDirectImplementers(){if(!$this->isInterface()){return array();}$that=$this->name;return array_filter($this->getBroker()->getClasses(Backend::INTERNAL_CLASSES|Backend::TOKENIZED_CLASSES),function(IReflectionClass$class)use($that){if(!$class->implementsInterface($that)){return false;}return null ===$class->getParentClassName()||!$class->getParentClass()->implementsInterface($that);});}public function getDirectImplementerNames(){return array_keys($this->getDirectImplementers());}public function getIndirectImplementers(){if(!$this->isInterface()){return array();}$that=$this->name;return array_filter($this->getBroker()->getClasses(Backend::INTERNAL_CLASSES|Backend::TOKENIZED_CLASSES),function(IReflectionClass$class)use($that){if(!$class->implementsInterface($that)){return false;}return null !==$class->getParentClassName()&&$class->getParentClass()->implementsInterface($that);});}public function getIndirectImplementerNames(){return array_keys($this->getIndirectImplementers());}public static function create(Reflector$internalReflection,Broker$broker){if(!$internalReflection instanceof InternalReflectionClass){throw new RuntimeException(sprintf('Invalid reflection instance provided (%s), ReflectionClass expected.',get_class($internalReflection)));}return$broker->getClass($internalReflection->getName());}}
 namespace TokenReflection\Php;use Reflector;use TokenReflection\IReflectionConstant,TokenReflection\Exception,TokenReflection\Broker,TokenReflection\ReflectionBase;class ReflectionConstant implements IReflection,IReflectionConstant{private$broker;private$declaringClassName;private$namespaceName;private$value;private$name;private$userDefined;public function __construct($name,$value,Broker$broker,ReflectionClass$parent=null){$this->name=$name;$this->value=$value;$this->broker=$broker;if(null !==$parent){$this->declaringClassName=$parent->getName();$this->userDefined=$parent->isUserDefined();}else{$declared=get_defined_constants(false);if(!isset($declared[$name])){$this->userDefined=true;}else{$declared=get_defined_constants(true);$this->userDefined=isset($declared['user'][$name]);}}}public function isInternal(){return!$this->userDefined;}public function isUserDefined(){return$this->userDefined;}public function getName(){return$this->name;}public function getValue(){return$this->value;}public function getBroker(){return$this->broker;}final public function __get($key){return ReflectionBase::get($this,$key);}final public function __isset($key){return ReflectionBase::exists($this,$key);}public function getAnnotations(){return array();}public function getAnnotation($name){return null;}public function hasAnnotation($name){return false;}public function getDeclaringClass(){if(null ===$this->declaringClassName){return null;}return$this->getBroker()->getClass($this->declaringClassName);}public function getDeclaringClassName(){return$this->declaringClassName;}public function getNamespaceName(){return$this->namespaceName === ReflectionNamespace::NO_NAMESPACE_NAME?null:$this->namespaceName;}public function inNamespace(){return null !==$this->getNamespaceName();}public function getValueDefinition(){return var_export($this->value,true);}public function getDocComment(){return false;}public function getInheritedDocComment(){return$this->getDocComment();}public function getStartLine(){return false;}public function getEndLine(){return false;}public function getFileName(){return false;}public function getShortName(){$name=$this->getName();if(null !==$this->namespaceName &&$this->namespaceName !== ReflectionNamespace::NO_NAMESPACE_NAME){$name=substr($name,strlen($this->namespaceName)+1);}return$name;}public function isTokenized(){return false;}public static function create(Reflector$internalReflection,Broker$broker){return null;}}
 namespace TokenReflection\Php;use TokenReflection\IReflectionExtension,TokenReflection\Broker,TokenReflection\ReflectionBase;use Reflector,ReflectionExtension as InternalReflectionExtension;use RuntimeException;class ReflectionExtension extends InternalReflectionExtension implements IReflection,IReflectionExtension{private$broker;private$classes;private$constants;private$functions;public function __construct($name,Broker$broker){parent::__construct($name);$this->broker=$broker;}public function isInternal(){return true;}public function isUserDefined(){return false;}public function getBroker(){return$this->broker;}final public function __get($key){return ReflectionBase::get($this,$key);}final public function __isset($key){return ReflectionBase::exists($this,$key);}public function getClasses(){if(null ===$this->classes){$broker=$this->broker;$this->classes=array_map(function($className)use($broker){return$broker->getClass($className);},$this->getClassNames());}return$this->classes;}public function getClass($name){$classes=$this->getClasses();return isset($classes[$name])?$classes[$name]:null;}public function getConstantReflections(){if(null ===$this->constants){$broker=$this->broker;$this->constants=array_map(function($constantName)use($broker){return$broker->getConstant($constantName);},array_keys($this->getConstants()));}return$this->constants;}public function getConstant($name){$constants=$this->getConstants();return isset($constants[$name])?$constants[$name]:false;}public function getConstantReflection($name){$constants=$this->getConstantReflections();return isset($constants[$name])?$constants[$name]:null;}public function getFunctions(){if(null ===$this->functions){$broker=$this->broker;$this->classes=array_map(function($functionName)use($broker){return$broker->getFunction($functionName);},array_keys(parent::getFunctions()));}return$this->functions;}public function getFunctionNames(){return array_keys($this->getFunctions());}public function getFunction($name){$functions=$this->getFunctions();return isset($functions[$name])?$functions[$name]:null;}public function isTokenized(){return false;}public static function create(Reflector$internalReflection,Broker$broker){static$cache=array();if(!$internalReflection instanceof InternalReflectionExtension){throw new RuntimeException(sprintf('Invalid reflection instance provided (%s), ReflectionExtension expected.',get_class($internalReflection)));}if(!isset($cache[$internalReflection->getName()])){$cache[$internalReflection->getName()]=new self($internalReflection->getName(),$broker);}return$cache[$internalReflection->getName()];}}
 namespace TokenReflection\Php;use TokenReflection\IReflectionParameter,TokenReflection\Broker,TokenReflection\ReflectionBase;use Reflector,ReflectionParameter as InternalReflectionParameter,ReflectionFunctionAbstract as InternalReflectionFunctionAbstract;use RuntimeException;class ReflectionParameter extends InternalReflectionParameter implements IReflection,IReflectionParameter{private$broker;private$userDefined;public function __construct($function,$paramName,Broker$broker,InternalReflectionFunctionAbstract$parent){parent::__construct($function,$paramName);$this->broker=$broker;$this->userDefined=$parent->isUserDefined();}public function isInternal(){return!$this->userDefined;}public function isUserDefined(){return$this->userDefined;}public function getBroker(){return$this->broker;}final public function __get($key){return ReflectionBase::get($this,$key);}final public function __isset($key){return ReflectionBase::exists($this,$key);}public function getDeclaringClass(){$class=parent::getDeclaringClass();return$class?ReflectionClass::create($class,$this->broker):null;}public function getDeclaringClassName(){$class=parent::getDeclaringClass();return$class?$class->getName():null;}public function getClassName(){return$this->getClass()?$this->getClass()->getName():null;}public function getDeclaringFunction(){$class=$this->getDeclaringClass();$function=parent::getDeclaringFunction();if($class){return$class->getMethod($function->getName());}else{return ReflectionFunction::create($function,$this->broker);}}public function getDeclaringFunctionName(){$function=parent::getDeclaringFunction();return$function?$function->getName():$function;}public function getDefaultValueDefinition(){$value=$this->getDefaultValue();return null ===$value?null:var_export($value,true);}public function getDocComment(){return false;}public function getInheritedDocComment(){return$this->getDocComment();}public function getStartLine(){return false;}public function getEndLine(){return false;}public function isTokenized(){return false;}public static function create(Reflector$internalReflection,Broker$broker){static$cache=array();if(!$internalReflection instanceof InternalReflectionParameter){throw new RuntimeException(sprintf('Invalid reflection instance provided (%s), ReflectionParameter expected.',get_class($internalReflection)));}$class=$internalReflection->getDeclaringClass();$function=$internalReflection->getDeclaringFunction();$key=$class?$class->getName().'::':'';$key .=$function->getName().'('.$internalReflection->getName().')';if(!isset($cache[$key])){$cache[$key]=new self($class?array($class->getName(),$function->getName()):$function->getName(),$internalReflection->getName(),$broker,$function);}return$cache[$key];}}
 namespace TokenReflection\Php;use TokenReflection\IReflectionProperty,TokenReflection\Broker,TokenReflection\ReflectionBase;use Reflector,ReflectionProperty as InternalReflectionProperty;use RuntimeException;class ReflectionProperty extends InternalReflectionProperty implements IReflection,IReflectionProperty{private$broker;public function __construct($class,$propertyName,Broker$broker){parent::__construct($class,$propertyName);$this->broker=$broker;}public function getBroker(){return$this->broker;}final public function __get($key){return ReflectionBase::get($this,$key);}final public function __isset($key){return ReflectionBase::exists($this,$key);}public function getDeclaringClass(){return ReflectionClass::create(parent::getDeclaringClass(),$this->broker);}public function getDeclaringClassName(){return$this->getDeclaringClass()->getName();}public function getClass(){return$this->getDeclaringClassName();}public function getDocComment(){return false;}public function getInheritedDocComment(){return$this->getDocComment();}public function getStartLine(){return false;}public function getEndLine(){return false;}public function getAnnotations(){return array();}public function getAnnotation($name){return null;}public function hasAnnotation($name){return false;}public function isInternal(){return$this->getDeclaringClass()->isInternal();}public function isUserDefined(){return$this->getDeclaringClass()->isUserDefined();}public function getDefaultValue(){$values=$this->getDeclaringClass()->getDefaultProperties();return$values[$this->getName()];}public function getDefaultValueDefinition(){$value=$this->getDefaultValue();return null ===$value?null:var_export($value,true);}public function isTokenized(){return false;}public static function create(Reflector$internalReflection,Broker$broker){static$cache=array();if(!$internalReflection instanceof InternalReflectionProperty){throw new RuntimeException(sprintf('Invalid reflection instance provided (%s), ReflectionProperty expected.',get_class($internalReflection)));}$key=$internalReflection->getDeclaringClass()->getName().'::'.$internalReflection->getName();if(!isset($cache[$key])){$cache[$key]=new self($internalReflection->getDeclaringClass()->getName(),$internalReflection->getName(),$broker);}return$cache[$key];}}
 namespace TokenReflection;use ReflectionClass as InternalReflectionClass,ReflectionProperty as InternalReflectionProperty;use RuntimeException,InvalidArgumentException;class ReflectionClass extends ReflectionBase implements IReflectionClass{const PACKAGE_NONE='None';const IS_INTERFACE=128;const IMPLEMENTS_INTERFACES=0x80000;private$namespaceName;private$constants=array();private$properties=array();private$methods=array();private$aliases=array();private$modifiers=0;private$parentClassName;private$interfaces=array();protected function processParent(IReflection$parent){if(!$parent instanceof ReflectionFileNamespace){throw new RuntimeException(sprintf('The parent object has to be an instance of TokenReflection\ReflectionFileNamespace, %s given.',get_class($parent)));}$this->namespaceName=$parent->getName();$this->aliases=$parent->getAliases();return parent::processParent($parent);}protected function parse(Stream$tokenStream,IReflection$parent){return parent::parse($tokenStream,$parent)->parseModifiers($tokenStream)->parseName($tokenStream)->parseParent($tokenStream,$parent)->parseInterfaces($tokenStream,$parent);}protected function parseChildren(Stream$tokenStream){while(true){switch($tokenStream->getType()){case null:break 2;case T_FUNCTION:$stream=$tokenStream->getMethodStream();$method=new ReflectionMethod($stream,$this->getBroker(),$this);$this->methods[$method->getName()]=$method;break;case T_CONST:$tokenStream->skipWhitespaces();while($tokenStream->is(T_STRING)){$stream=$tokenStream->getConstantStream();$constant=new ReflectionConstant($stream,$this->getBroker(),$this);$this->constants[$constant->getName()]=$constant;$tokenStream->skipWhitespaces();}break;case T_VARIABLE:$stream=$tokenStream->getPropertyStream();$property=new ReflectionProperty($stream,$this->getBroker(),$this);$this->properties[$property->getName()]=$property;break;default:$tokenStream->skipWhitespaces();}}return$this;}public function getConstant($name){try{return$this->getConstantReflection($name)->getValue();}catch(Exception$e){if($e->getCode()=== Exception::DOES_NOT_EXIST){return false;}throw$e;}}public function getConstantReflection($name){$constants=$this->getConstantReflections();if(isset($constants[$name])){return$constants[$name];}throw new Exception(sprintf('Constant "%s" is not defined in class "%s"',$name,$this->name),Exception::DOES_NOT_EXIST);}public function getConstants(){return array_map(function(IReflectionConstant$constant){return$constant->getValue();},$this->getConstantReflections());}public function getConstantReflections(){if(null ===$this->parentClassName){return$this->constants;}else{return array_merge($this->constants,$this->getParentClass()->getConstantReflections());}}public function getConstructor(){$methods=$this->getMethods();foreach($methods as$reflectionMethod){if($reflectionMethod->isConstructor()){return$reflectionMethod;}}return null;}public function getDestructor(){$methods=$this->getMethods();foreach($methods as$reflectionMethod){if($reflectionMethod->isDestructor()){return$reflectionMethod;}}return null;}public function getDefaultProperties(){$defaults=array();foreach($this->getProperties()as$name =>$property){if($property instanceof ReflectionProperty){$defaults[$name]=$property->getDefaultValue();}}return$defaults;}public function getInterfaceNames(){$parentClass=$this->getParentClass();$names=$parentClass?$parentClass->getInterfaceNames():array();foreach(array_reverse($this->interfaces)as$interfaceName){$names=array_merge($names,$this->getBroker()->getClass($interfaceName)->getInterfaceNames());$names[]=$interfaceName;}return array_unique($names);}public function getOwnInterfaceNames(){return array_reverse($this->interfaces);}public function getInterfaces(){$interfaceNames=$this->getInterfaceNames();if(empty($interfaceNames)){return array();}$broker=$this->getBroker();return array_combine($interfaceNames,array_map(function($interfaceName)use($broker){return$broker->getClass($interfaceName);},$interfaceNames));}public function getMethod($name){$methods=$this->getMethods();if(!isset($methods[$name])){throw new Exception(sprintf('There is no method %s in class %s',$name,$this->name),Exception::DOES_NOT_EXIST);}return$methods[$name];}public function getMethods($filter=null){$methods=$this->getOwnMethods($filter);if(null !==$this->parentClassName){$methods=array_merge($this->getParentClass()->getMethods($filter),$methods);}return$methods;}public function getModifiers(){if(($this->modifiers&InternalReflectionClass::IS_EXPLICIT_ABSTRACT)&&!($this->modifiers&InternalReflectionClass::IS_IMPLICIT_ABSTRACT)){foreach($this->getMethods()as$reflectionMethod){if($reflectionMethod->isAbstract()){$this->modifiers |= InternalReflectionClass::IS_IMPLICIT_ABSTRACT;}}}if(count($this->getInterfaceNames())){$this->modifiers |= self::IMPLEMENTS_INTERFACES;}return$this->modifiers;}public function getNamespaceName(){return$this->namespaceName === ReflectionNamespace::NO_NAMESPACE_NAME?null:$this->namespaceName;}public function getParentClass(){$className=$this->getParentClassName();if(null ===$className){return null;}return$this->getBroker()->getClass($className);}public function getParentClasses(){$parent=$this->getParentClass();if(null ===$parent){return array();}return array_merge(array($parent->getName()=>$parent),$parent->getParentClasses());}public function getParentClassNameList(){$parent=$this->getParentClass();if(null ===$parent){return array();}return array_merge(array($parent->getName()),$parent->getParentClassNameList());}public function getParentClassName(){return$this->parentClassName;}public function getProperties($filter=null){$properties=$this->getOwnProperties($filter);if(null !==$this->parentClassName){$properties=array_merge($this->getParentClass()->getProperties($filter),$properties);}return$properties;}public function getProperty($name){$properties=$this->getProperties();if(!isset($properties[$name])){throw new Exception(sprintf('There is no property %s in class %s',$name,$this->name),Exception::DOES_NOT_EXIST);}return$properties[$name];}public function getShortName(){$name=$this->getName();if($this->namespaceName !== ReflectionNamespace::NO_NAMESPACE_NAME){$name=substr($name,strlen($this->namespaceName)+1);}return$name;}public function getStaticProperties(){$defaults=array();foreach($this->getProperties(InternalReflectionProperty::IS_STATIC)as$name =>$property){if($property instanceof ReflectionProperty){$defaults[$name]=$property->getDefaultValue();}}return$defaults;}public function getStaticPropertyValue($name,$default=null){$properties=$this->getProperties(InternalReflectionProperty::IS_STATIC);if(!isset($properties[$name])){throw new Exception(sprintf('There is no static property %s in class %s',$name,$this->name),Exception::DOES_NOT_EXIST);}$property=$properties[$name];if(!$property instanceof ReflectionProperty){return$property->getDeclaringClass()->getStaticPropertyValue($name,$default);}if(!$property->isPublic()&&!$property->isAccessible()){throw new Exception('Only public or accessible properties can return thier values');}return$property->getDefaultValue();}public function getOwnInterfaces(){$interfaceNames=$this->getOwnInterfaceNames();if(empty($interfaceNames)){return array();}$broker=$this->getBroker();return array_combine($interfaceNames,array_map(function($interfaceName)use($broker){return$broker->getClass($interfaceName);},$interfaceNames));}public function getOwnMethods($filter=null){$methods=$this->methods;if(null !==$filter){$methods=array_filter($methods,function(ReflectionMethod$method)use($filter){return (bool)($method->getModifiers()&$filter);});}return$methods;}public function getOwnProperties($filter=null){$properties=$this->properties;if(null !==$filter){$properties=array_filter($properties,function(ReflectionProperty$property)use($filter){return (bool)($property->getModifiers()&$filter);});}return$properties;}public function getOwnConstants(){return array_map(function(ReflectionConstant$constant){return$constant->getValue();},$this->constants);}public function getOwnConstantReflections(){return$this->constants;}public function hasConstant($name){$constants=$this->getConstants();return isset($constants[$name]);}public function hasOwnConstant($name){return isset($this->constants[$name]);}public function hasMethod($name){$methods=$this->getMethods();return isset($methods[$name]);}public function hasOwnMethod($name){return isset($this->methods[$name]);}public function hasProperty($name){$properties=$this->getProperties();return isset($properties[$name]);}public function hasOwnProperty($name){return isset($this->properties[$name]);}public function implementsInterface($interface){if(is_object($interface)){if($interface instanceof InternalReflectionClass ||$interface instanceof IReflectionClass){$interfaceName=$interface->getName();}else{throw new InvalidArgumentException('Parameter must be a string or an instance of class reflection');}if(!$interface->isInterface()){throw new RuntimeException(sprintf('%s is not an interface.',$interfaceName));}}else{$reflection=$this->getBroker()->getClass($interface);if(!$reflection->isInterface()){throw new RuntimeException(sprintf('%s is not an interface.',$interface));}$interfaceName=$interface;}return in_array($interfaceName,$this->getInterfaceNames());}public function inNamespace(){return null !==$this->namespaceName &&ReflectionNamespace::NO_NAMESPACE_NAME !==$this->namespaceName;}public function isAbstract(){return (bool)($this->modifiers&InternalReflectionClass::IS_EXPLICIT_ABSTRACT);}public function isFinal(){return$this->modifiers === InternalReflectionClass::IS_FINAL;}public function isInstance($object){if(!is_object($object)){throw new Exception(sprintf('A class instance must be provided (%s set)',gettype($object)));}return$this->name === get_class($object)|| is_subclass_of($object,$this->name);}public function isInstantiable(){if($this->isInterface()||$this->isAbstract()){return false;}if(null ===($constructor=$this->getConstructor())){return true;}return$constructor->isPublic();}public function isCloneable(){if(!$this->isInstantiable()){return false;}$methods=$this->getMethods();return isset($methods['__clone'])?$methods['__clone']->isPublic():true;}public function isInterface(){return self::IS_INTERFACE ===$this->modifiers;}public function isException(){return 'Exception' ===$this->name ||$this->isSubclassOf('Exception');}public function isIterateable(){return$this->implementsInterface('Traversable');}public function isSubclassOf($class){if(is_object($class)){if(!$class instanceof InternalReflectionClass &&!$class instanceof IReflectionClass){throw new InvalidArgumentException('Parameter must be a string or an instance of class reflection');}$class=$class->getName();}if($class ===$this->parentClassName){return true;}$parent=$this->getParentClass();return null ===$parent?false:$parent->isSubclassOf($class);}public function getDirectSubclasses(){$that=$this->name;return array_filter($this->getBroker()->getClasses(),function(ReflectionClass$class)use($that){if(!$class->isSubclassOf($that)){return false;}return null ===$class->getParentClassName()||!$class->getParentClass()->isSubClassOf($that);});}public function getDirectSubclassNames(){return array_keys($this->getDirectSubclasses());}public function getIndirectSubclasses(){$that=$this->name;return array_filter($this->getBroker()->getClasses(),function(ReflectionClass$class)use($that){if(!$class->isSubclassOf($that)){return false;}return null !==$class->getParentClassName()&&$class->getParentClass()->isSubClassOf($that);});}public function getIndirectSubclassNames(){return array_keys($this->getIndirectSubclasses());}public function getDirectImplementers(){if(!$this->isInterface()){return array();}$that=$this->name;return array_filter($this->getBroker()->getClasses(),function(ReflectionClass$class)use($that){if(!$class->implementsInterface($that)){return false;}return null ===$class->getParentClassName()||!$class->getParentClass()->implementsInterface($that);});}public function getDirectImplementerNames(){return array_keys($this->getDirectImplementers());}public function getIndirectImplementers(){if(!$this->isInterface()){return array();}$that=$this->name;return array_filter($this->getBroker()->getClasses(),function(ReflectionClass$class)use($that){if(!$class->implementsInterface($that)){return false;}return null !==$class->getParentClassName()&&$class->getParentClass()->implementsInterface($that);});}public function getIndirectImplementerNames(){return array_keys($this->getIndirectImplementers());}public function getInheritedDocComment(){if(false !==($docComment=$this->getDocComment())){return$docComment;}return null ===$this->parentClassName?false:$this->getParentClass()->getInheritedDocComment();}public function newInstance($args){return$this->newInstanceArgs(func_get_args());}public function newInstanceArgs(array$args=array()){if(!class_exists($this->name,true)){throw new Exception(sprintf('Could not create an instance of class %s; class not found',$this->name));}$reflection=new InternalReflectionClass($this->name);return$reflection->newInstanceArgs($args);}public function setStaticPropertyValue($name,$value){$properties=$this->getProperties(InternalReflectionProperty::IS_STATIC);if(!isset($properties[$name])){throw new Exception(sprintf('There is no static property %s in class %s',$name,$this->name),Exception::DOES_NOT_EXIST);}$reflectionProperty=$properties[$name];if(!$reflectionProperty->isPublic()&&!$reflectionProperty->isAccessible()){throw new Exception(sprintf('Cannot set property value; property %s is not public nor set accessible.',$name));}$reflectionProperty->setDefaultValue($value);}private function parseModifiers(Stream$tokenStream){while(true){switch($tokenStream->getType()){case null:break 2;case T_ABSTRACT:$this->modifiers=InternalReflectionClass::IS_EXPLICIT_ABSTRACT;break;case T_FINAL:$this->modifiers=InternalReflectionClass::IS_FINAL;break;case T_INTERFACE:$this->modifiers=self::IS_INTERFACE;case T_CLASS:$tokenStream->skipWhitespaces();break 2;}$tokenStream->skipWhitespaces();}return$this;}protected function parseName(Stream$tokenStream){if(!$tokenStream->is(T_STRING)){throw new RuntimeException('The class name could not be determined');}if($this->namespaceName === ReflectionNamespace::NO_NAMESPACE_NAME){$this->name=$tokenStream->getTokenValue();}else{$this->name=$this->namespaceName.'\\'.$tokenStream->getTokenValue();}$tokenStream->skipWhitespaces();return$this;}private function parseParent(Stream$tokenStream,ReflectionBase$parent=null){if(!$tokenStream->is(T_EXTENDS)){return$this;}$tokenStream->skipWhitespaces();$parentClassName='';while(true){switch($tokenStream->getType()){case T_STRING:case T_NS_SEPARATOR:$parentClassName .=$tokenStream->getTokenValue();break;default:break 2;}$tokenStream->next();}$tokenStream->skipWhitespaces();$this->parentClassName=self::resolveClassFQN($parentClassName,$this->aliases,$this->namespaceName);return$this;}public function getNamespaceAliases(){return$this->aliases;}private function parseInterfaces(Stream$tokenStream,ReflectionBase$parent=null){if(!$tokenStream->is(T_IMPLEMENTS)){return$this;}while(true){$interfaceName='';$tokenStream->skipWhitespaces();while(true){switch($tokenStream->getType()){case T_STRING:case T_NS_SEPARATOR:$interfaceName .=$tokenStream->getTokenValue();break;default:break 2;}$tokenStream->next();}$this->interfaces[]=self::resolveClassFQN($interfaceName,$this->aliases,$this->namespaceName);$tokenStream->skipWhitespaces(false);$type=$tokenStream->getType();if('{' ===$type){break;}elseif(',' !==$type){throw new RuntimeException(sprintf('Invalid token found: "%s"',$tokenStream->getTokenName()));}}return$this;}}
 namespace TokenReflection;use RuntimeException;class ReflectionConstant extends ReflectionBase implements IReflectionConstant{private$declaringClassName;private$namespaceName;private$value;private$valueDefinition='';protected function processParent(IReflection$parent){if($parent instanceof ReflectionFileNamespace){$this->namespaceName=$parent->getName();}elseif($parent instanceof ReflectionClass){$this->declaringClassName=$parent->getName();}else{throw new RuntimeException(sprintf('The parent object has to be an instance of TokenReflection\ReflectionFileNamespace or TokenReflection\ReflectionClass, %s given.',get_class($parent)));}return parent::processParent($parent);}protected function parse(Stream$tokenStream,IReflection$parent){return parent::parse($tokenStream,$parent)->parseName($tokenStream)->parseValue($tokenStream);}protected function parseName(Stream$tokenStream){if($tokenStream->is(T_CONST)){$tokenStream->skipWhitespaces();}if(!$tokenStream->is(T_STRING)){throw new RuntimeException('Could not determine the constant name');}if(null ===$this->namespaceName ||$this->namespaceName === ReflectionNamespace::NO_NAMESPACE_NAME){$this->name=$tokenStream->getTokenValue();}else{$this->name=$this->namespaceName.'\\'.$tokenStream->getTokenValue();}$tokenStream->skipWhitespaces();return$this;}private function parseValue(Stream$tokenStream){if(!$tokenStream->is('=')){throw new RuntimeException('Could not find the value definition start');}$tokenStream->skipWhitespaces();static$acceptedStrings=array('true','false','null');$evalValue=true;while($tokenStream->valid()){$value=$tokenStream->getTokenValue();if($tokenStream->is(T_STRING)&&!in_array(strtolower($value),$acceptedStrings)){$evalValue=false;}$this->valueDefinition .=$value;$tokenStream->next();}if(',' ===$value || ';' ===$value){$this->valueDefinition=substr($this->valueDefinition,0,-1);}else{throw new RuntimeException(sprintf('Invalid value definition: "%s".',$this->valueDefinition));}if($evalValue){$this->value=eval(sprintf('return %s;',$this->valueDefinition));}return$this;}public function getValueDefinition(){return$this->valueDefinition;}public function getValue(){if(null ===$this->value &&'null' !== strtolower(trim($this->valueDefinition))){$constant=$this->getBroker()->getConstant($this->valueDefinition);if(null ===$constant){throw new RuntimeException(sprintf('Could not determine constant %s value.',$this->valueDefinition));}$this->value=$constant->getValue();}return$this->value;}public function getDeclaringClassName(){return$this->declaringClassName;}public function getClass(){return$this->getDeclaringClassName();}public function getDeclaringClass(){if(null ===$this->declaringClassName){return null;}return$this->getBroker()->getClass($this->declaringClassName);}public function getInheritedDocComment(){return$this->getDocComment();}public function getNamespaceName(){return$this->namespaceName === ReflectionNamespace::NO_NAMESPACE_NAME?null:$this->namespaceName;}public function inNamespace(){return null !==$this->getNamespaceName();}public function getShortName(){$name=$this->getName();if(null !==$this->namespaceName &&$this->namespaceName !== ReflectionNamespace::NO_NAMESPACE_NAME){$name=substr($name,strlen($this->namespaceName)+1);}return$name;}}
 namespace TokenReflection;use RuntimeException;class ReflectionFileNamespace extends ReflectionBase{private$aliases=array();private$classes=array();private$functions=array();private$constants=array();public function getClasses(){return$this->classes;}public function getFunctions(){return$this->functions;}public function getConstants(){return$this->constants;}public function getInheritedDocComment(){return$this->getDocComment();}public function getAliases(){return$this->aliases;}protected function processParent(IReflection$parent){if(!$parent instanceof ReflectionFile){throw new RuntimeException(sprintf('The parent object has to be an instance of TokenReflection\ReflectionFile, %s given.',get_class($parent)));}return parent::processParent($parent);}protected function parse(Stream$tokenStream,IReflection$parent){return parent::parse($tokenStream,$parent)->parseName($tokenStream)->parseAliases($tokenStream);}protected function parseChildren(Stream$tokenStream){while(true){switch($tokenStream->getType()){case null:break 2;case T_CLASS:case T_INTERFACE:$stream=$tokenStream->getClassStream();$class=new ReflectionClass($stream,$this->getBroker(),$this);$this->classes[$class->getName()]=$class;break;case T_CONST:$tokenStream->skipWhitespaces();while($tokenStream->is(T_STRING)){$stream=$tokenStream->getConstantStream();$constant=new ReflectionConstant($stream,$this->getBroker(),$this);$this->constants[$constant->getName()]=$constant;$tokenStream->skipWhitespaces();}break;case T_FUNCTION:static$skipped=array(T_WHITESPACE,T_COMMENT,T_DOC_COMMENT);$position=$tokenStream->key();while(in_array($type=$tokenStream->getType($position+1),$skipped)){$position++;}if('(' ===$type){$tokenStream->skipWhitespaces();continue;}$stream=$tokenStream->getFunctionStream();$function=new ReflectionFunction($stream,$this->getBroker(),$this);$this->functions[$function->getName()]=$function;break;default:$tokenStream->skipWhitespaces();}}return$this;}protected function parseName(Stream$tokenStream){if(!$tokenStream->is(T_NAMESPACE)){$this->name=ReflectionNamespace::NO_NAMESPACE_NAME;return$this;}$tokenStream->skipWhitespaces();$name='';while(true){switch($tokenStream->getType()){case T_STRING:case T_NS_SEPARATOR:$name .=$tokenStream->getTokenValue();break;default: break 2;}$tokenStream->next();}$name=ltrim($name,'\\');if(empty($name)){$this->name=ReflectionNamespace::NO_NAMESPACE_NAME;}else{$this->name=$name;$tokenStream->skipWhitespaces();}return$this;}private function parseAliases(Stream$tokenStream){if(ReflectionNamespace::NO_NAMESPACE_NAME ===$this->name){return$this;}$aliases=array();while(true){if($tokenStream->is(T_USE)){while(true){$namespaceName='';$alias=null;$tokenStream->skipWhitespaces();while(true){switch($tokenStream->getType()){case T_STRING:case T_NS_SEPARATOR:$namespaceName .=$tokenStream->getTokenValue();break;default:break 2;}$tokenStream->next();}$namespaceName=ltrim($namespaceName,'\\');if(empty($namespaceName)){throw new RuntimeException('Imported namespace name could not be determined');}elseif('\\' === substr($namespaceName,-1)){throw new RuntimeException(sprintf('Invalid namespace name "%s"',$namespaceName));}$tokenStream->skipWhitespaces(false);if($tokenStream->is(T_AS)){$tokenStream->skipWhitespaces();if(!$tokenStream->is(T_STRING)){throw new RuntimeException(sprintf('The imported namespace "%s" seems aliased but the alias name could not be determined',$namespaceName));}$alias=$tokenStream->getTokenValue();$tokenStream->skipWhitespaces();}else{if(false !==($pos=strrpos($namespaceName,'\\'))){$alias=substr($namespaceName,$pos+1);}else{$alias=$namespaceName;}}if(isset($aliases[$alias])){throw new RuntimeException(sprintf('Namespace alias "%s" already defined',$alias));}$aliases[$alias]=$namespaceName;$type=$tokenStream->getType();if(';' ===$type){$tokenStream->skipWhitespaces();continue 2;}elseif(',' ===$type){continue;}throw new RuntimeException(sprintf('Invalid token found: "%s"',$tokenStream->getTokenName()));}}else{break;}}$this->aliases=$aliases;return$this;}}
 namespace TokenReflection;use RuntimeException;abstract class ReflectionFunctionBase extends ReflectionBase implements IReflectionFunctionBase{protected$modifiers=0;private$staticVariables=array();protected$namespaceName;private$returnsReference=false;private$parameters=array();public function getModifiers(){return$this->modifiers;}public function inNamespace(){return null !==$this->getNamespaceName();}public function getNamespaceName(){return$this->namespaceName === ReflectionNamespace::NO_NAMESPACE_NAME?null:$this->namespaceName;}public function getNumberOfParameters(){return count($this->parameters);}public function getNumberOfRequiredParameters(){$count=0;array_walk($this->parameters,function(ReflectionParameter$parameter)use(&$count){if(!$parameter->isOptional()){$count++;}});return$count;}public function getParameters(){return$this->parameters;}public function getParameter($parameter){if(is_numeric($parameter)){if(isset($this->parameters[$parameter])){return$this->parameters[$parameter];}else{throw new Exception(sprintf('There is no parameter at position %d',$parameter),Exception::DOES_NOT_EXIST);}}else{foreach($this->parameters as$reflection){if($reflection->getName()===$parameter){return$reflection;}}throw new Exception(sprintf('There is no parameter %s',$parameter),Exception::DOES_NOT_EXIST);}}public function getStaticVariables(){return$this->staticVariables;}public function isClosure(){return false;}public function returnsReference(){return$this->returnsReference;}public function getName(){if(null !==$this->namespaceName &&ReflectionNamespace::NO_NAMESPACE_NAME !==$this->namespaceName){return$this->namespaceName.'\\'.$this->name;}return$this->name;}public function getShortName(){return$this->name;}protected function parseName(Stream$tokenStream){if(!$tokenStream->is(T_STRING)){throw new RuntimeException('Could not determine the method/function name');}$this->name=$tokenStream->getTokenValue();$tokenStream->skipWhitespaces();return$this;}final protected function parseChildren(Stream$tokenStream){return$this ->parseParameters($tokenStream)->parseStaticVariables($tokenStream);}final protected function parseParameters(Stream$tokenStream){if(!$tokenStream->is('(')){throw new RuntimeException('Could not determine parameters start');}$tokenStream->skipWhitespaces();while(null !==($type=$tokenStream->getType())&&')' !==$type){if(T_VARIABLE ===$type){$parameter=new ReflectionParameter($tokenStream->getParameterStream(),$this->getBroker(),$this);$this->parameters[]=$parameter;}if($tokenStream->is(')')){break;}else{$tokenStream->skipWhitespaces();}}return$this;}final protected function parseStaticVariables(Stream$tokenStream){return$this;}final protected function parseReturnsReference(Stream$tokenStream){if(!$tokenStream->is(T_FUNCTION)){throw new RuntimeException('Could not find the function keyword.');}$tokenStream->skipWhitespaces();$type=$tokenStream->getType();if('&' ===$type){$this->returnsReference=true;$tokenStream->skipWhitespaces();}elseif(!T_STRING ===$type){throw new RuntimeException(sprintf('Unexpected token type: %s',$tokenStream->getTokenName()));}return$this;}}
 namespace TokenReflection;use RuntimeException;class ReflectionNamespace implements IReflectionNamespace{const NO_NAMESPACE_NAME='no-namespace';private$broker;private$name;private$classes=array();private$functions=array();private$constants=array();public function __construct($name,Broker$broker){$this->name=$name;$this->broker=$broker;}public function getClass($className){$className=ltrim($className,'\\');if(false === strpos($className,'\\')&&self::NO_NAMESPACE_NAME !==$this->getName()){$className=$this->getName().'\\'.$className;}if(!isset($this->classes[$className])){throw new Exception(sprintf('Class %s does not exist',$className),Exception::DOES_NOT_EXIST);}return$this->classes[$className];}public function getClasses(){return$this->classes;}public function getClassNames(){return array_keys($this->classes);}public function getClassShortNames(){return array_map(function(IReflectionClass$class){return$class->getShortName();},$this->classes);}public function getFunction($functionName){$functionName=ltrim($functionName,'\\');if(false === strpos($functionName,'\\')&&self::NO_NAMESPACE_NAME !==$this->getName()){$functionName=$this->getName().'\\'.$functionName;}if(!isset($this->functions[$functionName])){throw new Exception(sprintf('Function %s does not exist',$functionName),Exception::DOES_NOT_EXIST);}return$this->functions[$functionName];}public function getFunctions(){return$this->functions;}public function getFunctionNames(){return array_keys($this->functions);}public function getFunctionShortNames(){return array_map(function(IReflectionFunction$function){return$function->getShortName();},$this->functions);}public function getConstant($constantName){$constantName=ltrim($constantName,'\\');if(false === strpos($constantName,'\\')&&self::NO_NAMESPACE_NAME !==$this->getName()){$constantName=$this->getName().'\\'.$constantName;}if(!isset($this->constants[$constantName])){throw new Exception(sprintf('Constant %s does not exist',$constantName),Exception::DOES_NOT_EXIST);}return$this->constants[$constantName];}public function getConstants(){return$this->constants;}public function getConstantNames(){return array_keys($this->constants);}public function getConstantShortNames(){return array_map(function(IReflectionConstant$constant){return$constant->getShortName();},$this->constants);}public function getName(){return$this->name;}public function getBroker(){return$this->broker;}public function isTokenized(){return true;}public function isInternal(){return false;}public function isUserDefined(){return true;}public function addFileNamespace(ReflectionFileNamespace$namespace){$classes=$namespace->getClasses();foreach($this->classes as$className =>$reflection){if(isset($classes[$className])){throw new RuntimeException(sprintf('Class %s was defined multiple times',$className));}}$this->classes=array_merge($this->classes,$classes);$functions=$namespace->getFunctions();foreach($this->functions as$functionName =>$reflection){if(isset($functions[$functionName])){throw new RuntimeException(sprintf('Function %s was defined multiple times',$functionName));}}$this->functions=array_merge($this->functions,$functions);$constants=$namespace->getConstants();foreach($this->constants as$constantName =>$reflection){if(isset($constants[$constantName])){throw new RuntimeException(sprintf('Constant %s was defined multiple times',$constantName));}}$this->constants=array_merge($this->constants,$constants);}public function __toString(){return '';}public static function export($argument,$return=false){return ReflectionBase::export($argument,$return);}final public function __get($key){return ReflectionBase::get($this,$key);}final public function __isset($key){return ReflectionBase::exists($this,$key);}}
 namespace TokenReflection;use RuntimeException,TokenReflection\Exception;class ReflectionParameter extends ReflectionBase implements IReflectionParameter{CONST ARRAY_CONSTRAINT='array';private static$parseValueDefinitions=false;private$valueConstraint;private$originalValueConstraint;private$defaultValueDefinition;private$defaultValue;private$declaringClassName;private$declaringFunctionName;private$passedByReference=false;private$isOptional;private$position;public function allowsNull(){return true;}public function getClass(){$name=$this->getClassName();if(null ===$name){return null;}return$this->getBroker()->getClass($name);}public function getClassName(){if($this->isArray()){return null;}if(null ===$this->valueConstraint &&null !==$this->originalValueConstraint){if(null !==$this->declaringClassName){$parent=$this->getDeclaringClass();if(null ===$parent ||!$parent->isTokenized()){throw new Exception(sprintf('Could not load class %s reflection',$this->declaringClassName));}}else{$parent=$this->getDeclaringFunction();if(null ===$parent ||!$parent->isTokenized()){throw new Exception(sprintf('Could not load function %s reflection',$this->declaringFunctionName));}}$this->valueConstraint=self::resolveClassFQN($this->originalValueConstraint,$parent->getNamespaceAliases(),$parent->getNamespaceName());}return$this->valueConstraint;}public function getOriginalClassName(){return!$this->isArray()?$this->originalValueConstraint:null;}public function getDeclaringClass(){return null ===$this->declaringClassName?null:$this->getBroker()->getClass($this->declaringClassName);}public function getDeclaringClassName(){return$this->declaringClassName;}public function getDeclaringFunction(){if(null !==$this->declaringClassName){$class=$this->getBroker()->getClass($this->declaringClassName);if(null !==$class){return$class->getMethod($this->declaringFunctionName);}}else{return$this->getBroker()->getFunction($this->declaringFunctionName);}}public function getDeclaringFunctionName(){return$this->declaringFunctionName;}public function getDefaultValue(){if(null ===$this->defaultValueDefinition){throw new Exception('Property has no default value',Exception::DOES_NOT_EXIST);}return$this->defaultValue;}public function getDefaultValueDefinition(){return$this->defaultValueDefinition;}public function getPosition(){return$this->position;}public function isArray(){return$this->valueConstraint === self::ARRAY_CONSTRAINT;}public function isDefaultValueAvailable(){return null !==$this->defaultValueDefinition;}public function getInheritedDocComment(){return$this->getDocComment();}public function isOptional(){if(null ===$this->isOptional){$function=$this->getDeclaringFunction();if(null ===$function){throw new RuntimeException(sprintf('Could not get the declaring function %s reflection.',$this->declaringFunctionName));}$this->isOptional=true;foreach(array_slice($function->getParameters(),$this->position)as$reflectionParameter){if(!$reflectionParameter->isDefaultValueAvailable()){$this->isOptional=false;break;}}}return$this->isOptional;}public function isPassedByReference(){return$this->passedByReference;}protected function processParent(IReflection$parent){if(!$parent instanceof ReflectionFunctionBase){throw new RuntimeException(sprintf('The parent object has to be an instance of TokenReflection\ReflectionFunctionBase descendant class, %s given.',get_class($parent)));}$this->declaringFunctionName=$parent->getName();$this->position=count($parent->getParameters());if($parent instanceof ReflectionMethod){$this->declaringClassName=$parent->getDeclaringClassName();}return parent::processParent($parent);}protected function parse(Stream$tokenStream,IReflection$parent){return$this ->parseConstraint($tokenStream)->parsePassedByReference($tokenStream)->parseName($tokenStream)->parseDefaultValue($tokenStream);}protected function parseName(Stream$tokenStream){if(!$tokenStream->is(T_VARIABLE)){throw new RuntimeException('Could not find the parameter variable definition');}$token=$tokenStream->current();$this->name=substr($token[1],1);$tokenStream->skipWhitespaces();return$this;}private function parseConstraint(Stream$tokenStream){$type=$tokenStream->getType();if(T_ARRAY ===$type){$this->valueConstraint=self::ARRAY_CONSTRAINT;$this->originalValueConstraint=self::ARRAY_CONSTRAINT;$tokenStream->skipWhitespaces();}elseif(T_STRING ===$type || T_NS_SEPARATOR ===$type){$className='';do{$token=$tokenStream->current();$className .=$token[1];$tokenStream->skipWhitespaces();$type=$tokenStream->getType();}while(T_STRING ===$type || T_NS_SEPARATOR ===$type);$className=ltrim($className,'\\');if(empty($className)){throw new RuntimeException('Invalid value constraint definition');}$this->originalValueConstraint=$className;}return$this;}private function parsePassedByReference(Stream$tokenStream){if($tokenStream->is('&')){$this->passedByReference=true;$tokenStream->skipWhitespaces();}return$this;}private function parseDefaultValue(Stream$tokenStream){if($tokenStream->is('=')){$tokenStream->skipWhitespaces();$this->defaultValueDefinition=Stream::tokensToCode(array_slice($tokenStream->getArrayCopy(),$tokenStream->key()));if(self::$parseValueDefinitions){$this->defaultValue=@eval('return '.$this->defaultValueDefinition.';');}}return$this;}public static function setParseValueDefinitions($parse){self::$parseValueDefinitions=(bool)$parse;}public static function getParseValueDefinitions(){return self::$parseValueDefinitions;}}
 namespace TokenReflection\Php;use TokenReflection\IReflectionFunction,TokenReflection\Broker,TokenReflection\ReflectionBase;use Reflector,ReflectionFunction as InternalReflectionFunction,ReflectionParameter as InternalReflectionParameter;use RuntimeException;class ReflectionFunction extends InternalReflectionFunction implements IReflection,IReflectionFunction{private$broker;private$parameters;public function __construct($functionName,Broker$broker){parent::__construct($functionName);$this->broker=$broker;}public function getBroker(){return$this->broker;}final public function __get($key){return ReflectionBase::get($this,$key);}final public function __isset($key){return ReflectionBase::exists($this,$key);}public function getExtension(){return ReflectionExtension::create(parent::getExtension(),$this->broker);}public function getParameters(){if(null ===$this->parameters){$broker=$this->broker;$parent=$this;$this->parameters=array_map(function(InternalReflectionParameter$parameter)use($broker,$parent){return ReflectionParameter::create($parameter,$broker,$parent);},parent::getParameters());}return$this->parameters;}public function getParameter($parameter){$parameters=$this->getParameters();if(is_numeric($parameter)){if(isset($parameters[$parameter])){return$parameters[$parameter];}else{throw new Exception(sprintf('There is no parameter at position %d',$parameter),Exception::DOES_NOT_EXIST);}}else{foreach($parameters as$reflection){if($reflection->getName()===$parameter){return$reflection;}}throw new Exception(sprintf('There is no parameter %s',$parameter),Exception::DOES_NOT_EXIST);}}public function getInheritedDocComment(){return$this->getDocComment();}public function getAnnotations(){return array();}public function getAnnotation($name){return null;}public function hasAnnotation($name){return false;}public function isTokenized(){return false;}public static function create(Reflector$internalReflection,Broker$broker){if(!$internalReflection instanceof InternalReflectionFunction){throw new RuntimeException(sprintf('Invalid reflection instance provided (%s), ReflectionFunction expected.',get_class($internalReflection)));}return$broker->getFunction($internalReflection->getName());}}
 namespace TokenReflection\Php;use TokenReflection\IReflectionMethod,TokenReflection\Broker,TokenReflection\ReflectionBase;use Reflector,ReflectionMethod as InternalReflectionMethod,ReflectionParameter as InternalReflectionParameter;use RuntimeException;class ReflectionMethod extends InternalReflectionMethod implements IReflection,IReflectionMethod{private$broker;private$parameters;public function __construct($class,$methodName,Broker$broker){parent::__construct($class,$methodName);$this->broker=$broker;}public function getBroker(){return$this->broker;}final public function __get($key){return ReflectionBase::get($this,$key);}final public function __isset($key){return ReflectionBase::exists($this,$key);}public function getParameters(){if(null ===$this->parameters){$broker=$this->broker;$parent=$this;$this->parameters=array_map(function(InternalReflectionParameter$parameter)use($broker,$parent){return ReflectionParameter::create($parameter,$broker,$parent);},parent::getParameters());}return$this->parameters;}public function getInheritedDocComment(){if(false !==($docComment=$this->getDocComment())){return$docComment;}$parent=$this->getDeclaringClass()->getParentClass();if($parent &&$parent->hasMethod($this->getName())){return$parent->getMethod($this->getName())->getInheritedDocComment();}return false;}public function getParameter($parameter){$parameters=$this->getParameters();if(is_numeric($parameter)){if(isset($parameters[$parameter])){return$parameters[$parameter];}else{throw new Exception(sprintf('There is no parameter at position %d',$parameter),Exception::DOES_NOT_EXIST);}}else{foreach($parameters as$reflection){if($reflection->getName()===$parameter){return$reflection;}}throw new Exception(sprintf('There is no parameter %s',$parameter),Exception::DOES_NOT_EXIST);}}public function getDeclaringClass(){return ReflectionClass::create(parent::getDeclaringClass(),$this->broker);}public function getDeclaringClassName(){return$this->getDeclaringClass()->getName();}public function getClass(){return$this->getDeclaringClassName();}public function getAnnotations(){return array();}public function getAnnotation($name){return null;}public function hasAnnotation($name){return false;}public function getPrototype(){return self::create(parent::getPrototype(),$this->broker);}public function isTokenized(){return false;}public static function create(Reflector$internalReflection,Broker$broker){static$cache=array();if(!$internalReflection instanceof InternalReflectionMethod){throw new RuntimeException(sprintf('Invalid reflection instance provided (%s), ReflectionMethod expected.',get_class($internalReflection)));}$key=$internalReflection->getDeclaringClass()->getName().'::'.$internalReflection->getName();if(!isset($cache[$key])){$cache[$key]=new self($internalReflection->getDeclaringClass()->getName(),$internalReflection->getName(),$broker);}return$cache[$key];}}
 namespace TokenReflection;use RuntimeException;class ReflectionFunction extends ReflectionFunctionBase implements IReflectionFunction{private$aliases=array();public function isDisabled(){return$this->hasAnnotation('disabled');}public function getInheritedDocComment(){return$this->getDocComment();}public function invoke(){return$this->invokeArgs(func_get_args());}public function invokeArgs(array$args=array()){if(!function_exists($this->getName())){throw new RuntimeException('Function %s is not defined in the current scope.',$this->getName());}return call_user_func_array($this->getName(),$args);}protected function parse(Stream$tokenStream,IReflection$parent){return parent::parse($tokenStream,$parent)->parseReturnsReference($tokenStream)->parseName($tokenStream);}protected function processParent(IReflection$parent){if(!$parent instanceof ReflectionFileNamespace){throw new RuntimeException(sprintf('The parent object has to be an instance of TokenReflection\ReflectionFileNamespace, %s given.',get_class($parent)));}$this->namespaceName=$parent->getName();$this->aliases=$parent->getAliases();return parent::processParent($parent);}public function getNamespaceAliases(){return$this->aliases;}}
 namespace TokenReflection;use ReflectionMethod as InternalReflectionMethod,ReflectionClass as InternalReflectionClass;use RuntimeException,InvalidArgumentException;class ReflectionMethod extends ReflectionFunctionBase implements IReflectionMethod{const IS_IMPLEMENTED_ABSTRACT=0x08;const ACCESS_LEVEL_CHANGED=0x800;const IS_CONSTRUCTOR=0x2000;const IS_DESTRUCTOR=0x4000;const IS_CLONE=0x8000;const IS_ALLOWED_STATIC=0x10000;private$declaringClassName;private$accessible=false;public function getDeclaringClass(){return null ===$this->declaringClassName?null:$this->getBroker()->getClass($this->declaringClassName);}public function getDeclaringClassName(){return$this->declaringClassName;}public function getClass(){return$this->getDeclaringClassName();}public function getInheritedDocComment(){if(false !==($docComment=$this->getDocComment())){return$docComment;}$parent=$this->getDeclaringClass()->getParentClass();if(null !==$parent &&$parent->hasMethod($this->getName())){return$parent->getMethod($this->getName())->getInheritedDocComment();}return false;}public function getModifiers(){if(!($this->modifiers&(self::ACCESS_LEVEL_CHANGED|self::IS_IMPLEMENTED_ABSTRACT))){$declaringClass=$this->getDeclaringClass();if(null ===$declaringClass){throw new RuntimeException('No declaring class defined.');}$parentClass=$declaringClass->getParentClass();if(null !==$parentClass){$parentClassMethods=$parentClass->getMethods();if($this->modifiers&InternalReflectionMethod::IS_PUBLIC){if(isset($parentClassMethods[$this->name])&&($parentClassMethods[$this->name]->getModifiers()&(self::ACCESS_LEVEL_CHANGED|InternalReflectionMethod::IS_PRIVATE))){$this->modifiers |= self::ACCESS_LEVEL_CHANGED;}}if(isset($parentClassMethods[$this->name])&&($parentClassMethods[$this->name]->getModifiers()&(self::IS_IMPLEMENTED_ABSTRACT|InternalReflectionMethod::IS_ABSTRACT))){$this->modifiers |= self::IS_IMPLEMENTED_ABSTRACT;}}}return$this->modifiers;}public function invoke($object,$args){$params=func_get_args();return$this->invokeArgs(array_shift($params),$params);}public function invokeArgs($object,array$args=array()){$declaringClass=$this->getDeclaringClass();if(!$declaringClass->isInstance($object)){throw new InvalidArgumentException(sprintf('Invalid class, %s expected %s given',$declaringClass->getName(),get_class($object)));}if($this->isPublic()){return call_user_func_array(array($object,$this->getName()),$args);}elseif($this->isAccessible()){$refClass=new InternalReflectionClass($object);$refMethod=$refClass->getMethod($this->name);$refMethod->setAccessible(true);$value=$refMethod->invokeArgs($object,$args);$refMethod->setAccessible(false);return$value;}throw new RuntimeException('Only public methods can be invoked.');}public function isAbstract(){return (bool)($this->modifiers&InternalReflectionMethod::IS_ABSTRACT);}public function isConstructor(){return (bool)($this->modifiers&self::IS_CONSTRUCTOR);}public function isDestructor(){return (bool)($this->modifiers&self::IS_DESTRUCTOR);}public function isFinal(){return (bool)($this->modifiers&InternalReflectionMethod::IS_FINAL);}public function isPrivate(){return (bool)($this->modifiers&InternalReflectionMethod::IS_PRIVATE);}public function isProtected(){return (bool)($this->modifiers&InternalReflectionMethod::IS_PROTECTED);}public function isPublic(){return (bool)($this->modifiers&InternalReflectionMethod::IS_PUBLIC);}public function isStatic(){return (bool)($this->modifiers&InternalReflectionMethod::IS_STATIC);}public function setAccessible($accessible){$this->accessible=$accessible;}public function isAccessible(){return$this->accessible;}public function getPrototype(){$declaring=$this->getDeclaringClass();if($declaring->getParentClassName()){foreach($declaring->getParentClass()->getMethods()as$method){if($method->getName()===$this->name &&!$method->isPrivate()){return$method;}}}foreach($declaring->getInterfaces()as$interface){if($interface->hasMethod($this->name)){return$interface->getMethod($this->name);}}throw new Exception('Method has no prototype',Exception::DOES_NOT_EXIST);}protected function processParent(IReflection$parent){if(!$parent instanceof ReflectionClass){throw new RuntimeException('The parent object has to be either an instance of TokenReflection\ReflectionClass or NULL, %s given.',get_class($parent));}$this->declaringClassName=$parent->getName();return parent::processParent($parent);}protected function parse(Stream$tokenStream,IReflection$parent){return parent::parse($tokenStream,$parent)->parseBaseModifiers($tokenStream)->parseReturnsReference($tokenStream)->parseName($tokenStream)->parseInternalModifiers($parent);}private function parseBaseModifiers(Stream$tokenStream){while(true){switch($tokenStream->getType()){case T_ABSTRACT:$this->modifiers |= InternalReflectionMethod::IS_ABSTRACT;break;case T_FINAL:$this->modifiers |= InternalReflectionMethod::IS_FINAL;break;case T_PUBLIC:$this->modifiers |= InternalReflectionMethod::IS_PUBLIC;break;case T_PRIVATE:$this->modifiers |= InternalReflectionMethod::IS_PRIVATE;break;case T_PROTECTED:$this->modifiers |= InternalReflectionMethod::IS_PROTECTED;break;case T_STATIC:$this->modifiers |= InternalReflectionMethod::IS_STATIC;break;case T_FUNCTION:case null:break 2;}$tokenStream->skipWhitespaces();}if(!($this->modifiers&InternalReflectionMethod::IS_PRIVATE)&&!($this->modifiers&InternalReflectionMethod::IS_PROTECTED)){$this->modifiers |= InternalReflectionMethod::IS_PUBLIC;}return$this;}private function parseInternalModifiers(ReflectionClass$class){$name=strtolower($this->name);if('__construct' ===$name ||($class &&!$class->inNamespace()&&strtolower($class->getShortName())===$name)){$this->modifiers |= self::IS_CONSTRUCTOR;}elseif('__destruct' ===$name){$this->modifiers |= self::IS_DESTRUCTOR;}elseif('__clone' ===$name){$this->modifiers |= self::IS_CLONE;}if(!$this->isConstructor()&&!$this->isDestructor()&&!in_array($name,array('__clone','__tostring','__get','__set','__isset','__unset'),true)){$this->modifiers |= self::IS_ALLOWED_STATIC;}return$this;}}
